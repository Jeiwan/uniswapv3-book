<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="NFT Manager Contract #  Obviously, we&rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the UniswapV3Manager contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And we&rsquo;re going to push this idea a little bit further."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="NFT Manager"><meta property="og:description" content="NFT Manager Contract #  Obviously, we&rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the UniswapV3Manager contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And we&rsquo;re going to push this idea a little bit further."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_6/nft-manager/"><meta property="article:section" content="docs"><title>NFT Manager | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.9d4c76002141b80988a3df602b5c5b07cc74377538f293dd1899100c44d569e8.js integrity="sha256-nUx2ACFBuAmIo99gK1xbB8x0N3U48pPdGJkQDETVaeg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. Introduction</span><ul><li><a href=/docs/introduction/introduction-to-markets/>Introduction to Markets</a></li><li><a href=/docs/introduction/constant-function-market-maker/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li><li><a href=/docs/introduction/what-we-will-build/>What We'll Build</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/ class=active>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>NFT Manager</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#nft-manager-contract>NFT Manager Contract</a><ul><li><a href=#the-minimal-contract>The Minimal Contract</a></li><li><a href=#minting>Minting</a></li><li><a href=#adding-liquidity>Adding Liquidity</a></li><li><a href=#remove-liquidity>Remove Liquidity</a></li><li><a href=#collecting-tokens>Collecting Tokens</a></li><li><a href=#burning>Burning</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=nft-manager-contract>NFT Manager Contract
<a class=anchor href=#nft-manager-contract>#</a></h1><p>Obviously, we&rsquo;re not going to add NFT-related functionality to the pool contract–we need a separate contract that will
merge NFTs and liquidity positions. Recall that, while working on our implementation, we built the <code>UniswapV3Manager</code>
contract to facilitate interaction with pool contracts (to make some calculations simpler and to enable multi-pool
swaps). This contract was a good demonstration of how core Uniswap contracts can be extended. And we&rsquo;re going to push
this idea a little bit further.</p><p>We&rsquo;ll need a manager contract that will implement the ERC721 standard and will manage liquidity positions. The contract
will have the standard NFT functionality (minting, burning, transferring, balances and ownership tracking, etc.) and will
allow to provide and remove liquidity to pools. The contract will need to be the actual owner of liquidity in pools
because we don&rsquo;t want to let users to add liquidity without minting a token and removing entire liquidity without burning
one. We want every liquidity position to be linked to an NFT token, and we want to them to be synchronized.</p><p>Let&rsquo;s see what functions we&rsquo;ll have in the new contract:</p><ol><li>since it&rsquo;ll be an NFT contract, it&rsquo;ll have all the ERC721 functions, including <code>tokenURI</code>, which returns the URI of
the image of an NFT token;</li><li><code>mint</code> and <code>burn</code> to mint and burn liquidity and NFT tokens at the same time;</li><li><code>addLiquidity</code> and <code>removeLiquidity</code> to add and remove liquidity in existing positions;</li><li><code>collect</code>, to collect tokens after removing liquidity.</li></ol><p>Alright, let&rsquo;s get to code.</p><h2 id=the-minimal-contract>The Minimal Contract
<a class=anchor href=#the-minimal-contract>#</a></h2><p>Since we don&rsquo;t want to implement the ERC721 standard from scratch, we&rsquo;re going to use a library. We already have <a href=https://github.com/transmissions11/solmate>Solmate</a>
in the dependencies, so we&rsquo;re going to use <a href=https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol>its ERC721 implementation</a>.</p><blockquote><p>Using <a href=https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721>the ERC721 implementation from OpenZeppelin</a>
is also an option, but I personally prefer the gas optimized contracts from Solmate.</p></blockquote><p>This will be the bare minimum of the NFT manager contract:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>contract</span> <span style=color:#a6e22e>UniswapV3NFTManager</span> <span style=color:#66d9ef>is</span> ERC721 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>immutable</span> factory;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(<span style=color:#66d9ef>address</span> factoryAddress)
</span></span><span style=display:flex><span>        ERC721(<span style=color:#e6db74>&#34;UniswapV3 NFT Positions&#34;</span>, <span style=color:#e6db74>&#34;UNIV3&#34;</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        factory <span style=color:#f92672>=</span> factoryAddress;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>tokenURI</span>(<span style=color:#66d9ef>uint256</span> tokenId)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>view</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>tokenURI</code> will return an empty string until we implement a metadata and SVG renderer. We&rsquo;ve added the stub so that
the Solidity compiler doesn&rsquo;t fail while we&rsquo;re working on the rest of the contract (the <code>tokenURI</code> function in the Solmate
ERC721 contract is virtual, so we must implement it).</p><h2 id=minting>Minting
<a class=anchor href=#minting>#</a></h2><p>Minting, as we discussed earlier, will involve two operations: adding liquidity to a pool and minting an NFT.</p><p>To keep the links between pool liquidity positions and NFTs, we&rsquo;ll need a mapping and a structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TokenPosition</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> pool;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> lowerTick;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> upperTick;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>mapping</span>(<span style=color:#66d9ef>uint256</span> <span style=color:#f92672>=&gt;</span> TokenPosition) <span style=color:#66d9ef>public</span> positions;
</span></span></code></pre></div><p>To find a position we need:</p><ol><li>a pool address;</li><li>an owner address;</li><li>the boundaries of a position (lower and upper ticks).</li></ol><p>Since the NFT manager contract will be the owner of all positions created via it, we don&rsquo;t need to store position&rsquo;s owner
address and we can only store the rest data. The keys in the <code>positions</code> mapping are token IDs; the mapping links NFT
IDs to the position data that&rsquo;s required to find a liquidity position.</p><p>Let&rsquo;s implement minting:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MintParams</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> recipient;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> tokenA;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> tokenB;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint24</span> fee;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> lowerTick;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> upperTick;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amount0Desired;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amount1Desired;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amount0Min;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amount1Min;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>mint</span>(MintParams calldata params) <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> tokenId) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The minting parameters are identical to those of <code>UniswapV3Manager</code>, with an addition of <code>recipient</code>, which will allow
to mint NFT to another address.</p><p>In the <code>mint</code> function, we first add liquidity to a pool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>IUniswapV3Pool pool <span style=color:#f92672>=</span> getPool(params.tokenA, params.tokenB, params.fee);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>uint128</span> liquidity, <span style=color:#66d9ef>uint256</span> amount0, <span style=color:#66d9ef>uint256</span> amount1) <span style=color:#f92672>=</span> _addLiquidity(
</span></span><span style=display:flex><span>    AddLiquidityInternalParams({
</span></span><span style=display:flex><span>        pool<span style=color:#f92672>:</span> pool,
</span></span><span style=display:flex><span>        lowerTick<span style=color:#f92672>:</span> params.lowerTick,
</span></span><span style=display:flex><span>        upperTick<span style=color:#f92672>:</span> params.upperTick,
</span></span><span style=display:flex><span>        amount0Desired<span style=color:#f92672>:</span> params.amount0Desired,
</span></span><span style=display:flex><span>        amount1Desired<span style=color:#f92672>:</span> params.amount1Desired,
</span></span><span style=display:flex><span>        amount0Min<span style=color:#f92672>:</span> params.amount0Min,
</span></span><span style=display:flex><span>        amount1Min<span style=color:#f92672>:</span> params.amount1Min
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p><code>_addLiquidity</code> is identical to the body of <code>mint</code> function in the <code>UniswapV3Manager</code> contract: it converts ticks to
$\sqrt(P)$, computes liquidity amount, and calls <code>pool.mint()</code>.</p><p>Next, we mint an NFT:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>tokenId <span style=color:#f92672>=</span> nextTokenId<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>_mint(params.recipient, tokenId);
</span></span><span style=display:flex><span>totalSupply<span style=color:#f92672>++</span>;
</span></span></code></pre></div><p><code>tokenId</code> is set to the current <code>nextTokenId</code> and the latter is then incremented. The <code>_mint</code> function is provided by
the ERC721 contract from Solmate. After minting a new token, we update <code>totalSupply</code>.</p><p>Finally, we need to store the information about the new token and the new position:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>TokenPosition <span style=color:#66d9ef>memory</span> tokenPosition <span style=color:#f92672>=</span> TokenPosition({
</span></span><span style=display:flex><span>    pool<span style=color:#f92672>:</span> <span style=color:#66d9ef>address</span>(pool),
</span></span><span style=display:flex><span>    lowerTick<span style=color:#f92672>:</span> params.lowerTick,
</span></span><span style=display:flex><span>    upperTick<span style=color:#f92672>:</span> params.upperTick
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>positions[tokenId] <span style=color:#f92672>=</span> tokenPosition;
</span></span></code></pre></div><p>This will later help us find liquidity position by token ID.</p><h2 id=adding-liquidity>Adding Liquidity
<a class=anchor href=#adding-liquidity>#</a></h2><p>Next, we&rsquo;ll implement a function to add liquidity to an existing position, in the case when we want more liquidity to
a position that already has some. In such cases, we don&rsquo;t want to mint an NFT, but only to increase the amount of liquidity
in an existing position. For that, we&rsquo;ll only need to provide a token ID and token amounts:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>addLiquidity</span>(AddLiquidityParams calldata params)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint128</span> liquidity,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amount0,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amount1
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    TokenPosition <span style=color:#66d9ef>memory</span> tokenPosition <span style=color:#f92672>=</span> positions[params.tokenId];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tokenPosition.pool <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(<span style=color:#ae81ff>0x00</span>)) revert WrongToken();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (liquidity, amount0, amount1) <span style=color:#f92672>=</span> _addLiquidity(
</span></span><span style=display:flex><span>        AddLiquidityInternalParams({
</span></span><span style=display:flex><span>            pool<span style=color:#f92672>:</span> IUniswapV3Pool(tokenPosition.pool),
</span></span><span style=display:flex><span>            lowerTick<span style=color:#f92672>:</span> tokenPosition.lowerTick,
</span></span><span style=display:flex><span>            upperTick<span style=color:#f92672>:</span> tokenPosition.upperTick,
</span></span><span style=display:flex><span>            amount0Desired<span style=color:#f92672>:</span> params.amount0Desired,
</span></span><span style=display:flex><span>            amount1Desired<span style=color:#f92672>:</span> params.amount1Desired,
</span></span><span style=display:flex><span>            amount0Min<span style=color:#f92672>:</span> params.amount0Min,
</span></span><span style=display:flex><span>            amount1Min<span style=color:#f92672>:</span> params.amount1Min
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function ensures there&rsquo;s an existing token and calls <code>pool.mint()</code> with parameters of an existing position.</p><h2 id=remove-liquidity>Remove Liquidity
<a class=anchor href=#remove-liquidity>#</a></h2><p>Recall that in the <code>UniswapV3Manager</code> contract we didn&rsquo;t implement a <code>burn</code> function because we wanted users to be owners
of liquidity positions. Now, we want the NFT manager to be the owner. And we can have liquidity burning implemented in
it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RemoveLiquidityParams</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> tokenId;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>removeLiquidity</span>(RemoveLiquidityParams <span style=color:#66d9ef>memory</span> params)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>    isApprovedOrOwner(params.tokenId)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint256</span> amount0, <span style=color:#66d9ef>uint256</span> amount1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    TokenPosition <span style=color:#66d9ef>memory</span> tokenPosition <span style=color:#f92672>=</span> positions[params.tokenId];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tokenPosition.pool <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(<span style=color:#ae81ff>0x00</span>)) revert WrongToken();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IUniswapV3Pool pool <span style=color:#f92672>=</span> IUniswapV3Pool(tokenPosition.pool);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>uint128</span> availableLiquidity, , , , ) <span style=color:#f92672>=</span> pool.positions(
</span></span><span style=display:flex><span>        poolPositionKey(tokenPosition)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (params.liquidity <span style=color:#f92672>&gt;</span> availableLiquidity) revert NotEnoughLiquidity();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (amount0, amount1) <span style=color:#f92672>=</span> pool.burn(
</span></span><span style=display:flex><span>        tokenPosition.lowerTick,
</span></span><span style=display:flex><span>        tokenPosition.upperTick,
</span></span><span style=display:flex><span>        params.liquidity
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;re again checking that provided token ID is valid. And we also need to ensure that a position has enough liquidity
to burn.</p><h2 id=collecting-tokens>Collecting Tokens
<a class=anchor href=#collecting-tokens>#</a></h2><p>The NFT manager contract can also collect tokens after burning liquidity. Notice that collected tokens are send to <code>msg.sender</code>
since the contract manages liquidity on behalf of the caller:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CollectParams</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> tokenId;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> amount0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> amount1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>collect</span>(CollectParams <span style=color:#66d9ef>memory</span> params)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span>
</span></span><span style=display:flex><span>    isApprovedOrOwner(params.tokenId)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint128</span> amount0, <span style=color:#66d9ef>uint128</span> amount1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    TokenPosition <span style=color:#66d9ef>memory</span> tokenPosition <span style=color:#f92672>=</span> positions[params.tokenId];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tokenPosition.pool <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(<span style=color:#ae81ff>0x00</span>)) revert WrongToken();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IUniswapV3Pool pool <span style=color:#f92672>=</span> IUniswapV3Pool(tokenPosition.pool);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (amount0, amount1) <span style=color:#f92672>=</span> pool.collect(
</span></span><span style=display:flex><span>        msg.sender,
</span></span><span style=display:flex><span>        tokenPosition.lowerTick,
</span></span><span style=display:flex><span>        tokenPosition.upperTick,
</span></span><span style=display:flex><span>        params.amount0,
</span></span><span style=display:flex><span>        params.amount1
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=burning>Burning
<a class=anchor href=#burning>#</a></h2><p>Finally, burning. Unlike the other functions of the contract, this function doesn&rsquo;t do anything with a pool: it only
burns an NFT. And to burn an NFT, the underlying position must be empty and tokens must be collected. So, if we want
to burn an NFT, we need to:</p><ol><li>call <code>removeLiquidity</code> an remove the entire position liquidity;</li><li>call <code>collect</code> to collect the tokens after burning the position;</li><li>call <code>burn</code> to burn the token.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>burn</span>(<span style=color:#66d9ef>uint256</span> tokenId) <span style=color:#66d9ef>public</span> isApprovedOrOwner(tokenId) {
</span></span><span style=display:flex><span>    TokenPosition <span style=color:#66d9ef>memory</span> tokenPosition <span style=color:#f92672>=</span> positions[tokenId];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tokenPosition.pool <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(<span style=color:#ae81ff>0x00</span>)) revert WrongToken();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IUniswapV3Pool pool <span style=color:#f92672>=</span> IUniswapV3Pool(tokenPosition.pool);
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>uint128</span> liquidity, , , <span style=color:#66d9ef>uint128</span> tokensOwed0, <span style=color:#66d9ef>uint128</span> tokensOwed1) <span style=color:#f92672>=</span> pool
</span></span><span style=display:flex><span>        .positions(poolPositionKey(tokenPosition));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (liquidity <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> tokensOwed0 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> tokensOwed1 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        revert PositionNotCleared();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> positions[tokenId];
</span></span><span style=display:flex><span>    _burn(tokenId);
</span></span><span style=display:flex><span>    totalSupply<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it!</p><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#nft-manager-contract>NFT Manager Contract</a><ul><li><a href=#the-minimal-contract>The Minimal Contract</a></li><li><a href=#minting>Minting</a></li><li><a href=#adding-liquidity>Adding Liquidity</a></li><li><a href=#remove-liquidity>Remove Liquidity</a></li><li><a href=#collecting-tokens>Collecting Tokens</a></li><li><a href=#burning>Burning</a></li></ul></li></ul></nav></div></aside></main></body></html>