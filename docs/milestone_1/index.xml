<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Milestone 1. First Swap on Uniswap V3 Development Book</title><link>https://uniswapv3book.com/docs/milestone_1/</link><description>Recent content in Milestone 1. First Swap on Uniswap V3 Development Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://uniswapv3book.com/docs/milestone_1/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_1/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/introduction/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] You&amp;rsquo;ll find the complete code of this chapter in this Github branch.
First Swap # In this milestone, we&amp;rsquo;ll build a pool contract that can receive liquidity from users and make swaps within a price range.</description></item><item><title>Calculating Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/calculating-liquidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Calculating liquidity # Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.</description></item><item><title>Providing Liquidity</title><link>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/providing-liquidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Providing Liquidity # Enough of theory, let&amp;rsquo;s start coding!
Create a new folder (mine is called uniswapv3-code), and run forge init --vscode in it–this will initialize a Forge project.</description></item><item><title>First Swap</title><link>https://uniswapv3book.com/docs/milestone_1/first-swap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/first-swap/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] First Swap # Now that we have liquidity, we can make our first swap!
Calculating Swap Amounts # First step, of course, is to figure out how to calculate swap amounts.</description></item><item><title>Manager Contract</title><link>https://uniswapv3book.com/docs/milestone_1/manager-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/manager-contract/</guid><description>Manager Contract # Before deploying our pool contract, we need to solve one problem. As you remember, Uniswap V3 contracts are split into two categories:
Core contracts that implement the core functions and don&amp;rsquo;t provide user-friendly interfaces. Periphery contracts that implement user-friendly interfaces for the core contracts. The pool contract is a core contract, it&amp;rsquo;s not supposed to be user-friendly and flexible. It expects the caller to do all the calculations (prices, amounts) and to provide proper call parameters.</description></item><item><title>Deployment</title><link>https://uniswapv3book.com/docs/milestone_1/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/deployment/</guid><description>Deployment # Alright, our contract is done. Now, let&amp;rsquo;s see how we can deploy it to a local Ethereum network so we could use it from a front-end app later on.
Choosing Local Blockchain Network # Smart contracts development requires running a local network, where you deploy your contracts during development and testing. This is what we want from such a network:
Real blockchain. It must be a real Ethereum network, not an emulation.</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_1/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_1/user-interface/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] User Interface # Finally, we made it to the final stop of this milestone–building a user interface!</description></item></channel></rss>