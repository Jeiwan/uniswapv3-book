<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Milestone 2. Second Swap on Uniswap V3 Development Book</title><link>https://uniswapv3book.com/docs/milestone_2/</link><description>Recent content in Milestone 2. Second Swap on Uniswap V3 Development Book</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://uniswapv3book.com/docs/milestone_2/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://uniswapv3book.com/docs/milestone_2/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/introduction/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] You&amp;rsquo;ll find the complete code of this chapter in this Github branch.
This milestone introduces a lot of code changes in existing contracts.</description></item><item><title>Output Amount Calculation</title><link>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/output-amount-calculation/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Output Amount Calculation # Our collection of Uniswap math formulas lacks a final piece: the formula of calculating the output amount when selling ETH (that is: selling token $X$).</description></item><item><title>Math in Solidity</title><link>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/math-in-solidity/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Math in Solidity # Due to Solidity not supporting float-point and fixed-point numbers, math in Solidity is somewhat complicated.</description></item><item><title>Tick Bitmap Index</title><link>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/tick-bitmap-index/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Tick Bitmap Index # As the first step towards dynamic swaps, we need to implement an index of ticks.</description></item><item><title>Generalize Minting</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-minting/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Minting # Now, we&amp;rsquo;re ready to update mint function so it calculates the amounts of tokens instead of hard coding them.</description></item><item><title>Generalize Swapping</title><link>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/generalize-swapping/</guid><description>function renderKatex(element) { renderMathInElement(document.body, { delimiters: [ { left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true } ], throwOnError: false }); } \[ \] Generalize Swapping # This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.</description></item><item><title>Quoter Contract</title><link>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/quoter-contract/</guid><description>Quoter Contract # To integrate our updated Pool contract into the front end app, we need a way to calculate swap amounts without making a swap. Users will type in the amount they want to sell, and we want to calculate and show them the amount they&amp;rsquo;ll get in exchange. We&amp;rsquo;ll do this through Quoter contract.
Since liquidity in Uniswap V3 is scattered over multiple price ranges, we cannot calculate swap amounts with a formula (which was possible in Uniswap V2).</description></item><item><title>User Interface</title><link>https://uniswapv3book.com/docs/milestone_2/user-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://uniswapv3book.com/docs/milestone_2/user-interface/</guid><description>User Interface # Let&amp;rsquo;s make our web app work more like a real DEX. We can now remove hardcoded swap amounts and let users type arbitrary amounts. Moreover, we can now let users swap in the both direction, so we also need a button to swap the token inputs. After updating, the swap form will look like:
&amp;lt;form className=&amp;#34;SwapForm&amp;#34;&amp;gt; &amp;lt;SwapInput amount={zeroForOne ? amount0 : amount1} disabled={!enabled || loading} readOnly={false} setAmount={setAmount_(zeroForOne ?</description></item></channel></rss>