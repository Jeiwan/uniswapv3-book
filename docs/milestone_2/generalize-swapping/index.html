<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Generalize Swapping #  This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.
You can think of a swap as of filling of an order: a user submits an order to buy a specified amount of tokens from a pool. The pool will use the available liquidity to &ldquo;convert&rdquo; the input amount into an output amount of the other token."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Generalize Swapping"><meta property="og:description" content="Generalize Swapping #  This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of swapping in Uniswap V3 works.
You can think of a swap as of filling of an order: a user submits an order to buy a specified amount of tokens from a pool. The pool will use the available liquidity to &ldquo;convert&rdquo; the input amount into an output amount of the other token."><meta property="og:type" content="article"><meta property="og:url" content="https://uniswapv3book.com/docs/milestone_2/generalize-swapping/"><meta property="article:section" content="docs"><title>Generalize Swapping | Uniswap V3 Development Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.9d4c76002141b80988a3df602b5c5b07cc74377538f293dd1899100c44d569e8.js integrity="sha256-nUx2ACFBuAmIo99gK1xbB8x0N3U48pPdGJkQDETVaeg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Uniswap V3 Development Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Milestone 0. Introduction</span><ul><li><a href=/docs/introduction/introduction-to-markets/>Introduction to Markets</a></li><li><a href=/docs/introduction/constant-function-market-maker/>Constant Function Market Makers</a></li><li><a href=/docs/introduction/uniswap-v3/>Uniswap V3</a></li><li><a href=/docs/introduction/dev-environment/>Development Environment</a></li><li><a href=/docs/introduction/what-we-will-build/>What We'll Build</a></li></ul></li><li class=book-section-flat><span>Milestone 1. First Swap</span><ul><li><a href=/docs/milestone_1/introduction/>Introduction</a></li><li><a href=/docs/milestone_1/calculating-liquidity/>Calculating Liquidity</a></li><li><a href=/docs/milestone_1/providing-liquidity/>Providing Liquidity</a></li><li><a href=/docs/milestone_1/first-swap/>First Swap</a></li><li><a href=/docs/milestone_1/manager-contract/>Manager Contract</a></li><li><a href=/docs/milestone_1/deployment/>Deployment</a></li><li><a href=/docs/milestone_1/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 2. Second Swap</span><ul><li><a href=/docs/milestone_2/introduction/>Introduction</a></li><li><a href=/docs/milestone_2/output-amount-calculation/>Output Amount Calculation</a></li><li><a href=/docs/milestone_2/math-in-solidity/>Math in Solidity</a></li><li><a href=/docs/milestone_2/tick-bitmap-index/>Tick Bitmap Index</a></li><li><a href=/docs/milestone_2/generalize-minting/>Generalize Minting</a></li><li><a href=/docs/milestone_2/generalize-swapping/ class=active>Generalize Swapping</a></li><li><a href=/docs/milestone_2/quoter-contract/>Quoter Contract</a></li><li><a href=/docs/milestone_2/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 3. Cross-tick Swaps</span><ul><li><a href=/docs/milestone_3/introduction/>Introduction</a></li><li><a href=/docs/milestone_3/different-ranges/>Different Price Ranges</a></li><li><a href=/docs/milestone_3/cross-tick-swaps/>Cross-Tick Swaps</a></li><li><a href=/docs/milestone_3/slippage-protection/>Slippage Protection</a></li><li><a href=/docs/milestone_3/liquidity-calculation/>Liquidity Calculation</a></li><li><a href=/docs/milestone_3/more-on-fixed-point-numbers/>A Little Bit More on Fixed-point Numbers</a></li><li><a href=/docs/milestone_3/flash-loans/>Flash Loans</a></li><li><a href=/docs/milestone_3/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 4. Multi-pool Swaps</span><ul><li><a href=/docs/milestone_4/introduction/>Introduction</a></li><li><a href=/docs/milestone_4/factory-contract/>Factory Contract</a></li><li><a href=/docs/milestone_4/path/>Swap Path</a></li><li><a href=/docs/milestone_4/multi-pool-swaps/>Multi-pool Swaps</a></li><li><a href=/docs/milestone_4/user-interface/>User Interface</a></li><li><a href=/docs/milestone_4/tick-rounding/>Tick Rounding</a></li></ul></li><li class=book-section-flat><span>Milestone 5. Fees and Price Oracle</span><ul><li><a href=/docs/milestone_5/introduction/>Introduction</a></li><li><a href=/docs/milestone_5/swap-fees/>Swap Fees</a></li><li><a href=/docs/milestone_5/flash-loan-fees/>Flash Loan Fees</a></li><li><a href=/docs/milestone_5/protocol-fees/>Protocol Fees</a></li><li><a href=/docs/milestone_5/price-oracle/>Price Oracle</a></li><li><a href=/docs/milestone_5/user-interface/>User Interface</a></li></ul></li><li class=book-section-flat><span>Milestone 6: NFT positions</span><ul><li><a href=/docs/milestone_6/introduction/>Introduction</a></li><li><a href=/docs/milestone_6/erc721-overview/>ERC721 Overview</a></li><li><a href=/docs/milestone_6/nft-manager/>NFT Manager</a></li><li><a href=/docs/milestone_6/nft-renderer/>NFT Renderer</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Generalize Swapping</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#generalize-swapping>Generalize Swapping</a><ul><li><a href=#filling-orders>Filling Orders</a></li><li><a href=#swapmath-contract>SwapMath Contract</a></li><li><a href=#finding-price-by-swap-amount>Finding Price by Swap Amount</a></li><li><a href=#finishing-the-swap>Finishing the Swap</a></li><li><a href=#testing>Testing</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=generalize-swapping>Generalize Swapping
<a class=anchor href=#generalize-swapping>#</a></h1><p>This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of
swapping in Uniswap V3 works.</p><p>You can think of a swap as of filling of an order: a user submits an order to buy a specified amount of tokens from a pool.
The pool will use the available liquidity to &ldquo;convert&rdquo; the input amount into an output amount of the other token. If there&rsquo;s
not enough liquidity in the current price range, it&rsquo;ll try to find liquidity in other price ranges (using the function
we implemented in the previous chapter).</p><p>We&rsquo;re now going to implement this logic in the <code>swap</code> function, however going to stay only within the current price range
for now–we&rsquo;ll implement cross-tick swaps in the next milestone.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>swap</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> recipient,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> zeroForOne,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountSpecified,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bytes</span> calldata data
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>int256</span> amount0, <span style=color:#66d9ef>int256</span> amount1) {
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>In <code>swap</code> function, we add two new parameters: <code>zeroForOne</code> and <code>amountSpecified</code>. <code>zeroForOne</code> is the flag that controls
swap direction: when <code>true</code>, <code>token0</code> is traded in for <code>token1</code>; when <code>false,</code> it&rsquo;s the opposite. For example, if <code>token0</code>
is ETH and <code>token1</code> is USDC, setting <code>zeroForOne</code> to <code>true</code> means buying USDC for ETH. <code>amountSpecified</code> is the amount of
tokens user wants to sell.</p><h2 id=filling-orders>Filling Orders
<a class=anchor href=#filling-orders>#</a></h2><p>Since, in Uniswap V3, liquidity is stored in multiple price ranges, Pool contract needs to find all liquidity that&rsquo;s
required to &ldquo;fill an order&rdquo; from user. This is done via iterating over initialized ticks in a direction chosen by
user.</p><p>Before continuing, we need to define two new structures:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SwapState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountSpecifiedRemaining;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountCalculated;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceX96;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> tick;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StepState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceStartX96;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int24</span> nextTick;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceNextX96;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountIn;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountOut;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>SwapState</code> maintains current swap&rsquo;s state. <code>amountSpecifiedRemaining</code> tracks the remaining amount of tokens that needs
to be bought by the pool. When it&rsquo;s zero, the swap is done. <code>amountCalculated</code> is the out amount calculated by the contract.
<code>sqrtPriceX96</code> and <code>tick</code> are new current price and tick after a swap is done.</p><p><code>StepState</code> maintains current swap step&rsquo;s state. This structure tracks the state of <strong>one iteration</strong> of an &ldquo;order filling&rdquo;.
<code>sqrtPriceStartX96</code> tracks the price the iteration begins with. <code>nextTick</code> is the next initialized tick that will provide
liquidity for the swap and <code>sqrtPriceNextX96</code> is the price at the next tick. <code>amountIn</code> and <code>amountOut</code> are amounts that
can be provided by the liquidity of the current iteration.</p><blockquote><p>After we implement cross-tick swaps (that is, swaps that happen across multiple price ranges), the idea of iterating
will be clearer.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/UniswapV3Pool.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>swap</span>(...) {
</span></span><span style=display:flex><span>    Slot0 <span style=color:#66d9ef>memory</span> slot0_ <span style=color:#f92672>=</span> slot0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SwapState <span style=color:#66d9ef>memory</span> state <span style=color:#f92672>=</span> SwapState({
</span></span><span style=display:flex><span>        amountSpecifiedRemaining<span style=color:#f92672>:</span> amountSpecified,
</span></span><span style=display:flex><span>        amountCalculated<span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>        sqrtPriceX96<span style=color:#f92672>:</span> slot0_.sqrtPriceX96,
</span></span><span style=display:flex><span>        tick<span style=color:#f92672>:</span> slot0_.tick
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>Before filling an order, we initialize a <code>SwapState</code> instance. We&rsquo;ll loop until <code>amountSpecifiedRemaining</code> is 0, which
will mean that the pool has enough liquidity to buy <code>amountSpecified</code> tokens from user.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> (state.amountSpecifiedRemaining <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    StepState <span style=color:#66d9ef>memory</span> step;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    step.sqrtPriceStartX96 <span style=color:#f92672>=</span> state.sqrtPriceX96;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (step.nextTick, ) <span style=color:#f92672>=</span> tickBitmap.nextInitializedTickWithinOneWord(
</span></span><span style=display:flex><span>        state.tick,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        zeroForOne
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    step.sqrtPriceNextX96 <span style=color:#f92672>=</span> TickMath.getSqrtRatioAtTick(step.nextTick);
</span></span></code></pre></div><p>In the loop, we set up a price range that should provide liquidity for the swap. The range is from <code>state.sqrtPriceX96</code>
to <code>step.sqrtPriceNextX96</code>, where the latter is the price at the next initialized tick (as returned by
<code>nextInitializedTickWithinOneWord</code>–we know this function from a previous chapter).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(state.sqrtPriceX96, step.amountIn, step.amountOut) <span style=color:#f92672>=</span> SwapMath
</span></span><span style=display:flex><span>    .computeSwapStep(
</span></span><span style=display:flex><span>        state.sqrtPriceX96,
</span></span><span style=display:flex><span>        step.sqrtPriceNextX96,
</span></span><span style=display:flex><span>        liquidity,
</span></span><span style=display:flex><span>        state.amountSpecifiedRemaining
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>Next, we&rsquo;re calculating the amounts that can be provider by the current price range, and the new current price the swap
will result in.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    state.amountSpecifiedRemaining <span style=color:#f92672>-=</span> step.amountIn;
</span></span><span style=display:flex><span>    state.amountCalculated <span style=color:#f92672>+=</span> step.amountOut;
</span></span><span style=display:flex><span>    state.tick <span style=color:#f92672>=</span> TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The final step in the loop is updating the SwapState. <code>step.amountIn</code> is the amount of tokens the price range can buy
from user; <code>step.amountOut</code> is the related number of the other token the pool can sell to user. <code>state.sqrtPriceX96</code> is
the current price that will be set after the swap (recall that trading changes current price).</p><h2 id=swapmath-contract>SwapMath Contract
<a class=anchor href=#swapmath-contract>#</a></h2><p>Let&rsquo;s look closer at <code>SwapMath.computeSwapStep</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/SwapMath.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>computeSwapStep</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceTargetX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountRemaining
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pure</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>returns</span> (
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint160</span> sqrtPriceNextX96,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amountIn,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> amountOut
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>This is the core logic of swapping. The function calculates swap amounts within one price range and respecting available
liquidity. It&rsquo;ll return: the new current price and input and output token amounts. Even though the input amount is provided
by user, we still calculate it to know how much of the user specified input amount was processed by one call to <code>computeSwapStep</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>bool</span> zeroForOne <span style=color:#f92672>=</span> sqrtPriceCurrentX96 <span style=color:#f92672>&gt;=</span> sqrtPriceTargetX96;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sqrtPriceNextX96 <span style=color:#f92672>=</span> Math.getNextSqrtPriceFromInput(
</span></span><span style=display:flex><span>    sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>    liquidity,
</span></span><span style=display:flex><span>    amountRemaining,
</span></span><span style=display:flex><span>    zeroForOne
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>By checking the price, we can determine the direction of the swap. Knowing the direction, we can calculate the price after
swapping <code>amountRemaining</code> of tokens. We&rsquo;ll return to this function below.</p><p>After finding the new price, we can calculate input and output amounts of the swap using the function we already have (
the same functions we used to calculate token amounts from liquidity in the <code>mint</code> function):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>amountIn <span style=color:#f92672>=</span> Math.calcAmount0Delta(
</span></span><span style=display:flex><span>    sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>    sqrtPriceNextX96,
</span></span><span style=display:flex><span>    liquidity
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>amountOut <span style=color:#f92672>=</span> Math.calcAmount1Delta(
</span></span><span style=display:flex><span>    sqrtPriceCurrentX96,
</span></span><span style=display:flex><span>    sqrtPriceNextX96,
</span></span><span style=display:flex><span>    liquidity
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>And swap the amounts if the direction is opposite:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>zeroForOne) {
</span></span><span style=display:flex><span>    (amountIn, amountOut) <span style=color:#f92672>=</span> (amountOut, amountIn);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s it for <code>computeSwapStep</code>!</p><h2 id=finding-price-by-swap-amount>Finding Price by Swap Amount
<a class=anchor href=#finding-price-by-swap-amount>#</a></h2><p>Let&rsquo;s now look at <code>Math.getNextSqrtPriceFromInput</code>–the function calculates a $\sqrt{P}$ given another $\sqrt{P}$,
liquidity, and input amount. It tells what the price will be after swapping the specified input amount of tokens, given
the current price and liquidity.</p><p>Good news is that we already know the formulas: recall how we calculated <code>price_next</code> in Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># When amount_in is token0</span>
</span></span><span style=display:flex><span>price_next <span style=color:#f92672>=</span> int((liq <span style=color:#f92672>*</span> q96 <span style=color:#f92672>*</span> sqrtp_cur) <span style=color:#f92672>//</span> (liq <span style=color:#f92672>*</span> q96 <span style=color:#f92672>+</span> amount_in <span style=color:#f92672>*</span> sqrtp_cur))
</span></span><span style=display:flex><span><span style=color:#75715e># When amount_in is token1</span>
</span></span><span style=display:flex><span>price_next <span style=color:#f92672>=</span> sqrtp_cur <span style=color:#f92672>+</span> (amount_in <span style=color:#f92672>*</span> q96) <span style=color:#f92672>//</span> liq
</span></span></code></pre></div><p>We&rsquo;re going to implement this in Solidity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#75715e>// src/lib/Math.sol
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getNextSqrtPriceFromInput</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountIn,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> zeroForOne
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint160</span> sqrtPriceNextX96) {
</span></span><span style=display:flex><span>    sqrtPriceNextX96 <span style=color:#f92672>=</span> zeroForOne
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> getNextSqrtPriceFromAmount0RoundingUp(
</span></span><span style=display:flex><span>            sqrtPriceX96,
</span></span><span style=display:flex><span>            liquidity,
</span></span><span style=display:flex><span>            amountIn
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> getNextSqrtPriceFromAmount1RoundingDown(
</span></span><span style=display:flex><span>            sqrtPriceX96,
</span></span><span style=display:flex><span>            liquidity,
</span></span><span style=display:flex><span>            amountIn
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function handles swapping in both directions. Since calculations are different, we&rsquo;ll implement them in separate
functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getNextSqrtPriceFromAmount0RoundingUp</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountIn
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint160</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> numerator <span style=color:#f92672>=</span> <span style=color:#66d9ef>uint256</span>(liquidity) <span style=color:#f92672>&lt;&lt;</span> FixedPoint96.RESOLUTION;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> product <span style=color:#f92672>=</span> amountIn <span style=color:#f92672>*</span> sqrtPriceX96;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (product <span style=color:#f92672>/</span> amountIn <span style=color:#f92672>==</span> sqrtPriceX96) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> denominator <span style=color:#f92672>=</span> numerator <span style=color:#f92672>+</span> product;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (denominator <span style=color:#f92672>&gt;=</span> numerator) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>uint160</span>(
</span></span><span style=display:flex><span>                    mulDivRoundingUp(numerator, sqrtPriceX96, denominator)
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint160</span>(
</span></span><span style=display:flex><span>            divRoundingUp(numerator, (numerator <span style=color:#f92672>/</span> sqrtPriceX96) <span style=color:#f92672>+</span> amountIn)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this function, we&rsquo;re implementing two formulas. At the first <code>return</code>, it implements the same formula we implemented
in Python. This is the most precise formula, but it can overflow when multiplying <code>amountIn</code> by <code>sqrtPriceX96</code>. The
formula is (we discussed it in &ldquo;Output Amount Calculation&rdquo;):
$$\sqrt{P_{target}} = \frac{\sqrt{P}L}{\Delta x \sqrt{P} + L}$$</p><p>When it overflows, we use an alternative formula, which is less precise:
$$\sqrt{P_{target}} = \frac{L}{\Delta x + \frac{L}{\sqrt{P}}}$$</p><p>Which is simply the previous formula with the numerator and the denominator divided by $\sqrt{P}$ to get rid of the multiplication
in the numerator.</p><p>The other function has simpler math:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getNextSqrtPriceFromAmount1RoundingDown</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint160</span> sqrtPriceX96,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> liquidity,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> amountIn
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>uint160</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        sqrtPriceX96 <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint160</span>((amountIn <span style=color:#f92672>&lt;&lt;</span> FixedPoint96.RESOLUTION) <span style=color:#f92672>/</span> liquidity);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=finishing-the-swap>Finishing the Swap
<a class=anchor href=#finishing-the-swap>#</a></h2><p>Now, let&rsquo;s return to the <code>swap</code> function and finish it.</p><p>By this moment, we have looped over next initialized ticks, filled <code>amountSpecified</code> specified by user, calculated input
and amount amounts, and found new price and tick. Since, in this milestone, we&rsquo;re implementing only swaps within one price
range, this is enough. We now need to update contract&rsquo;s state, send tokens to user, and get
tokens in exchange.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (state.tick <span style=color:#f92672>!=</span> slot0_.tick) {
</span></span><span style=display:flex><span>    (slot0.sqrtPriceX96, slot0.tick) <span style=color:#f92672>=</span> (state.sqrtPriceX96, state.tick);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, we set new price and tick. Since this operation writes to contract&rsquo;s storage, we want to do it only if the new
tick is different, to optimize gas consumption.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>(amount0, amount1) <span style=color:#f92672>=</span> zeroForOne
</span></span><span style=display:flex><span>    <span style=color:#f92672>?</span> (
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int256</span>(amountSpecified <span style=color:#f92672>-</span> state.amountSpecifiedRemaining),
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#66d9ef>int256</span>(state.amountCalculated)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> (
</span></span><span style=display:flex><span>        <span style=color:#f92672>-</span><span style=color:#66d9ef>int256</span>(state.amountCalculated),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int256</span>(amountSpecified <span style=color:#f92672>-</span> state.amountSpecifiedRemaining)
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>Next, we calculate swap amounts based on swap direction and the amounts calculated during the swap loop.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>if</span> (zeroForOne) {
</span></span><span style=display:flex><span>    IERC20(token1).transfer(recipient, <span style=color:#66d9ef>uint256</span>(<span style=color:#f92672>-</span>amount1));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> balance0Before <span style=color:#f92672>=</span> balance0();
</span></span><span style=display:flex><span>    IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
</span></span><span style=display:flex><span>        amount0,
</span></span><span style=display:flex><span>        amount1,
</span></span><span style=display:flex><span>        data
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (balance0Before <span style=color:#f92672>+</span> <span style=color:#66d9ef>uint256</span>(amount0) <span style=color:#f92672>&gt;</span> balance0())
</span></span><span style=display:flex><span>        revert InsufficientInputAmount();
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    IERC20(token0).transfer(recipient, <span style=color:#66d9ef>uint256</span>(<span style=color:#f92672>-</span>amount0));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> balance1Before <span style=color:#f92672>=</span> balance1();
</span></span><span style=display:flex><span>    IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
</span></span><span style=display:flex><span>        amount0,
</span></span><span style=display:flex><span>        amount1,
</span></span><span style=display:flex><span>        data
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (balance1Before <span style=color:#f92672>+</span> <span style=color:#66d9ef>uint256</span>(amount1) <span style=color:#f92672>&gt;</span> balance1())
</span></span><span style=display:flex><span>        revert InsufficientInputAmount();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we&rsquo;re exchanging tokens with user, depending on swap direction. This piece is identical to what we had in Milestone 2,
only handling of the other swap direction was added.</p><p>That&rsquo;s it! Swapping is done!</p><h2 id=testing>Testing
<a class=anchor href=#testing>#</a></h2><p>Test won&rsquo;t change significantly, we only need to pass <code>amountSpecified</code> and <code>zeroForOne</code> to <code>swap</code> function. Output amount
will change insignificantly though, because it&rsquo;s now calculated in Solidity.</p><p>We can now test swapping in the opposite direction! I&rsquo;ll leave this for you, as a homework (just be sure to choose a
small input amount so the whole swap can be handled by our single price range). Don&rsquo;t hesitate peeking at <a href=https://github.com/Jeiwan/uniswapv3-code/blob/milestone_2/test/UniswapV3Pool.t.sol>my tests</a>
if this feels difficult!</p><link rel=stylesheet href=/katex/katex.min.css><script>function renderKatex(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})}</script><script defer src=/katex/katex.min.js></script>
<script defer src=/katex/auto-render.min.js onload=renderKatex(document.body)></script><span>
\[ \]</span></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#generalize-swapping>Generalize Swapping</a><ul><li><a href=#filling-orders>Filling Orders</a></li><li><a href=#swapmath-contract>SwapMath Contract</a></li><li><a href=#finding-price-by-swap-amount>Finding Price by Swap Amount</a></li><li><a href=#finishing-the-swap>Finishing the Swap</a></li><li><a href=#testing>Testing</a></li></ul></li></ul></nav></div></aside></main></body></html>