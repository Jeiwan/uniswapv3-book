
<h1 id="tick-bitmap-index">Tick Bitmap Index</h1>

<p>As the first step towards dynamic swaps, we need to implement an index of ticks. In the previous milestone, we used to
calculate the target tick when making a swap:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">swap</span><span class="p">(</span><span class="kt">address</span> <span class="n">recipient</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">public</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">int256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">amount1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int24</span> <span class="n">nextTick</span> <span class="o">=</span> <span class="mi">85184</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When there’s liquidity provided in different price ranges, we cannot simply calculate the target tick. We need to <strong>find
it</strong> depending on the amount of liquidity in different price ranges. Thus, we need to index all ticks that have liquidity
and then use the index to find ticks to “fill” enough liquidity for a swap. In this step, we’re going to implement such
index.</p>

<h2 id="bitmap">Bitmap</h2>

<p>Bitmap is a popular technique of indexing data in a compact way. A bitmap is simply an array of zeros and ones, where
each element as and index and corresponds to some external entity (something that’s indexed). Each element can be a zero
or a one, which can be seemed as setting a flag: when 0, flag is not set; when 1, flag is set. What makes this approach
favorable is that the whole array can be stored as a single number in the binary number system!</p>

<p>For example, the array <code class="language-plaintext highlighter-rouge">111101001101001</code> is number 31337. The number takes two bytes (0x7a69) and two bytes can store 16
flags (1 byte = 8 bits).</p>

<p>Uniswap V3 uses this technique to store the information about initialized ticks, that is ticks with some liquidity. When
a flag is set (1), the tick has liquidity; when flag is not set (0), the tick is not initialized. Let’s review the
implementation.</p>

<h2 id="tickbitmap-contract">TickBitmap Contract</h2>

<p>In the pool contract, the tick index is stored in a state variable:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">contract</span> <span class="n">UniswapV3Pool</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">TickBitmap</span> <span class="k">for</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">int16</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">);</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int16</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">)</span> <span class="k">public</span> <span class="n">tickBitmap</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is mapping where keys are <code class="language-plaintext highlighter-rouge">int16</code>’s and values are words (<code class="language-plaintext highlighter-rouge">uint256</code>). Imagine an infinite continuous array of ones
and zeros:</p>

<p>[TODO: add illustration]</p>

<p>Each element in this array corresponds to a tick. To navigate in this array, we break it into words: sub-arrays of
length 256 bits. To find tick’s position in this array, we do:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">position</span><span class="p">(</span><span class="kt">int24</span> <span class="n">tick</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">int16</span> <span class="n">wordPos</span><span class="p">,</span> <span class="kt">uint8</span> <span class="n">bitPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wordPos</span> <span class="o">=</span> <span class="kt">int16</span><span class="p">(</span><span class="n">tick</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">bitPos</span> <span class="o">=</span> <span class="kt">uint8</span><span class="p">(</span><span class="kt">uint24</span><span class="p">(</span><span class="n">tick</span> <span class="o">%</span> <span class="mi">256</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That is: we find its word position and then its bit in this word. <code class="language-plaintext highlighter-rouge">&gt;&gt; 8</code> is identical to division by 256. So, word
position is the integer part of tick index divided by 256, and bit position is the remainder.</p>

<p>As an example, let’s calculate word and bit positions for one of our ticks:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tick</span> <span class="o">=</span> <span class="mi">85176</span>
<span class="n">word_pos</span> <span class="o">=</span> <span class="n">tick</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span> <span class="c1"># or tick // 2**8
</span><span class="n">bit_pos</span> <span class="o">=</span> <span class="n">tick</span> <span class="o">%</span> <span class="mi">256</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Word </span><span class="si">{</span><span class="n">word_pos</span><span class="si">}</span><span class="s">, bit </span><span class="si">{</span><span class="n">bit_pos</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Word 332, bit 184
</span></code></pre></div></div>

<h3 id="flipping-flags">Flipping Flags</h3>

<p>When adding liquidity into a pool, we need to set a couple of tick flags in the bitmap: one for the lower tick and one
for the upper tick. We do this in <code class="language-plaintext highlighter-rouge">flipTick</code> method of the bitmap mapping:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">flipTick</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int16</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tickSpacing</span>
<span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
    <span class="nb">require</span><span class="p">(</span><span class="n">tick</span> <span class="o">%</span> <span class="n">tickSpacing</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// ensure that the tick is spaced
</span>    <span class="p">(</span><span class="kt">int16</span> <span class="n">wordPos</span><span class="p">,</span> <span class="kt">uint8</span> <span class="n">bitPos</span><span class="p">)</span> <span class="o">=</span> <span class="n">position</span><span class="p">(</span><span class="n">tick</span> <span class="o">/</span> <span class="n">tickSpacing</span><span class="p">);</span>
    <span class="kt">uint256</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitPos</span><span class="p">;</span>
    <span class="n">self</span><span class="p">[</span><span class="n">wordPos</span><span class="p">]</span> <span class="o">^=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Until later in the book, <code class="language-plaintext highlighter-rouge">tickSpacing</code> is always 1.</p>
</blockquote>

<p>After finding word and bit positions, we need to make a mask. A mask is a number that has a single 1 flag set at the
bit position of the tick. To find the mask, we simply calculate <code class="language-plaintext highlighter-rouge">2**bit_pos</code> (equivalent of <code class="language-plaintext highlighter-rouge">1 &lt;&lt; bit_pos</code>):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">bit_pos</span> <span class="c1"># or 1 &lt;&lt; bit_pos
</span><span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
<span class="c1">#0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</span></code></pre></div></div>

<p>Next, to flip a flag, we apply the mask to the tick’s word via bitwise XOR:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">256</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># set word to all ones
</span><span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="n">word</span> <span class="o">^</span> <span class="n">mask</span><span class="p">))</span>
<span class="c1">#0b11111111111111111111111111111111111111111111111111111111111111111111111-&gt;0&lt;-1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
</span></code></pre></div></div>

<p>You’ll see that 184th bit (counting from the right starting at 0) has flipped to 0.</p>

<h3 id="finding-next-tick">Finding Next Tick</h3>

<p>Next step is finding ticks with liquidity using the bitmap index.</p>

<p>During swapping, we need to find a tick with liquidity that’s before or after the current tick (that is: to the left or
to the right of it). In the previous milestone, we used to <a href="https://github.com/Jeiwan/uniswapv3-code/blob/85b8605c37a9065c141a234ee2c18d9507eeba22/src/UniswapV3Pool.sol#L142">calculate and hard code it</a>,
but now we need to find such tick using the bitmap index. We’ll do this in <code class="language-plaintext highlighter-rouge">TickMath.nextInitializedTickWithinOneWord</code>
method. In this function, we’ll need to implement two scenarios:</p>

<ol>
  <li>When selling token $X$ (ETH in our case), find next initialized tick in the current tick’s word and <strong>to the right</strong> of the current tick.</li>
  <li>When selling token $Y$ (USDC in our case), find next initialized tick in the next (current + 1) tick’s word and <strong>to the left</strong> of the current tick.</li>
</ol>

<p>This corresponds to the price movement when making swaps in either directions:</p>

<p>[TODO: add illustration, price change direction and tick change direction]</p>

<p>We include the current price when price grows.</p>

<p>Now, let’s look at the implementation:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">nextInitializedTickWithinOneWord</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int16</span> <span class="o">=&gt;</span> <span class="kt">uint256</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tickSpacing</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">lte</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">int24</span> <span class="n">next</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">initialized</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int24</span> <span class="n">compressed</span> <span class="o">=</span> <span class="n">tick</span> <span class="o">/</span> <span class="n">tickSpacing</span><span class="p">;</span>
    <span class="p">...</span>
</code></pre></div></div>

<ol>
  <li>First arguments makes this function a method of <code class="language-plaintext highlighter-rouge">mapping(int16 =&gt; uint256)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">tick</code> is the current tick.</li>
  <li><code class="language-plaintext highlighter-rouge">tickSpacing</code> is always 1 until we start using it in Milestone 3.</li>
  <li><code class="language-plaintext highlighter-rouge">lte</code> is the flag that sets the direction. When <code class="language-plaintext highlighter-rouge">true</code>, we’re selling token $X$ and searching for next initialized tick
to the right of the current one. When <code class="language-plaintext highlighter-rouge">false,</code> it’s the other way around.</li>
</ol>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">lte</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">int16</span> <span class="n">wordPos</span><span class="p">,</span> <span class="kt">uint8</span> <span class="n">bitPos</span><span class="p">)</span> <span class="o">=</span> <span class="n">position</span><span class="p">(</span><span class="n">compressed</span><span class="p">);</span>
    <span class="kt">uint256</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitPos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitPos</span><span class="p">);</span>
    <span class="kt">uint256</span> <span class="n">masked</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">wordPos</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>When selling $X$, we’re:</p>
<ol>
  <li>taking current tick’s word and bit positions;</li>
  <li>making a mask where all bits to the right of the current bit position, including it, are ones (<code class="language-plaintext highlighter-rouge">mask</code> is all ones,
its length = <code class="language-plaintext highlighter-rouge">bitPos</code>);</li>
  <li>applying the mask to the current tick’s word.</li>
</ol>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">...</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="n">masked</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">initialized</span>
        <span class="o">?</span> <span class="p">(</span><span class="n">compressed</span> <span class="o">-</span> <span class="kt">int24</span><span class="p">(</span><span class="kt">uint24</span><span class="p">(</span><span class="n">bitPos</span> <span class="o">-</span> <span class="n">BitMath</span><span class="p">.</span><span class="n">mostSignificantBit</span><span class="p">(</span><span class="n">masked</span><span class="p">))))</span> <span class="o">*</span> <span class="n">tickSpacing</span>
        <span class="o">:</span> <span class="p">(</span><span class="n">compressed</span> <span class="o">-</span> <span class="kt">int24</span><span class="p">(</span><span class="kt">uint24</span><span class="p">(</span><span class="n">bitPos</span><span class="p">)))</span> <span class="o">*</span> <span class="n">tickSpacing</span><span class="p">;</span>
    <span class="p">...</span>
</code></pre></div></div>
<p>Next, <code class="language-plaintext highlighter-rouge">masked</code> won’t equal 0 if at least one bit of it is set to 1. If so, there’s an initialized tick; if not, there
isn’t (not in the current word). Depending on the result, we either return the index of the next initialized tick or the
leftmost bit in the next word–this will allow to search for initialized ticks in the word during another loop cycle.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">int16</span> <span class="n">wordPos</span><span class="p">,</span> <span class="kt">uint8</span> <span class="n">bitPos</span><span class="p">)</span> <span class="o">=</span> <span class="n">position</span><span class="p">(</span><span class="n">compressed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">uint256</span> <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bitPos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">uint256</span> <span class="n">masked</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">wordPos</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>Similarly, when selling $Y$, we’re:</p>
<ol>
  <li>taking next tick’s word and bit positions;</li>
  <li>making a different mask, where all bits to the left of next tick bit position are ones and all the bits to the right
are zeros;</li>
  <li>applying the mask to the next tick’s word.</li>
</ol>

<p>Again, if there’s no initialized ticks to the left, the rightmost bit of the previous word is returned:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">...</span>
    <span class="n">initialized</span> <span class="o">=</span> <span class="n">masked</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
</span>    <span class="n">next</span> <span class="o">=</span> <span class="n">initialized</span>
        <span class="o">?</span> <span class="p">(</span><span class="n">compressed</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="kt">int24</span><span class="p">(</span><span class="kt">uint24</span><span class="p">((</span><span class="n">BitMath</span><span class="p">.</span><span class="n">leastSignificantBit</span><span class="p">(</span><span class="n">masked</span><span class="p">)</span> <span class="o">-</span> <span class="n">bitPos</span><span class="p">))))</span> <span class="o">*</span> <span class="n">tickSpacing</span>
        <span class="o">:</span> <span class="p">(</span><span class="n">compressed</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="kt">int24</span><span class="p">(</span><span class="kt">uint24</span><span class="p">((</span><span class="k">type</span><span class="p">(</span><span class="kt">uint8</span><span class="p">).</span><span class="n">max</span> <span class="o">-</span> <span class="n">bitPos</span><span class="p">))))</span> <span class="o">*</span> <span class="n">tickSpacing</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And that’s it!</p>

<p>As you can see, <code class="language-plaintext highlighter-rouge">nextInitializedTickWithinOneWord</code> doesn’t find the exact tick–it’s scope of search is current or next
tick’s word. Indeed, we don’t want to iterate over all the words since the we don’t send boundaries on the bitmap index.
This function, however, plays well with <code class="language-plaintext highlighter-rouge">swap</code> function–soon, we’ll see this.</p>
