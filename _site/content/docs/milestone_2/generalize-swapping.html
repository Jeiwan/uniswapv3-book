
<h1 id="generalize-swapping">Generalize Swapping</h1>

<p>This will be the hardest chapter of this milestone. Before updating the code, we need to understand how the algorithm of
swapping in Uniswap V3 works.</p>

<p>You can think of swap as order fillings. A user submits an order to buy a specified amount of tokens to a pool. The pool
needs to “fill” the amount specified by the user, send tokens to the user, and request some amount of the other token in
exchange. This “filling” of an order is what we’re going to do in <code class="language-plaintext highlighter-rouge">swap</code> function.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">swap</span><span class="p">(</span>
    <span class="kt">address</span> <span class="n">recipient</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">zeroForOne</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amountSpecified</span><span class="p">,</span>
    <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span>
<span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">int256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">amount1</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">swap</code> function, we add two new parameters: <code class="language-plaintext highlighter-rouge">zeroForOne</code> and <code class="language-plaintext highlighter-rouge">amountSpecified</code>. <code class="language-plaintext highlighter-rouge">zeroForOne</code> is the flag that controls
swap direction: when <code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">token0</code> is traded in for <code class="language-plaintext highlighter-rouge">token1</code>; when <code class="language-plaintext highlighter-rouge">false,</code> it’s the opposite. For example, if <code class="language-plaintext highlighter-rouge">token0</code>
is ETH and <code class="language-plaintext highlighter-rouge">token1</code> is USDC, <code class="language-plaintext highlighter-rouge">zeroForOne</code> means buying USDC for ETH. <code class="language-plaintext highlighter-rouge">amountSpecified</code> is the amount of tokens user
wants to sell.</p>

<h2 id="filling-orders">Filling Orders</h2>

<p>Since, in Uniswap V3, liquidity is stored in multiple price ranges, Pool contract needs to find all liquidity that’s
required to “fill an order” from user. This is done via <strong>iterating</strong> over initialized ticks in a direction chosen by
user.</p>

<p>Before continuing, we need to define two new structures:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SwapState</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="n">amountSpecifiedRemaining</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">amountCalculated</span><span class="p">;</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">;</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">StepState</span> <span class="p">{</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceStartX96</span><span class="p">;</span>
    <span class="kt">int24</span> <span class="n">nextTick</span><span class="p">;</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceNextX96</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">amountIn</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">amountOut</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">SwapState</code> maintains current swap’s state. <code class="language-plaintext highlighter-rouge">amountSpecifiedRemaining</code> tracks the remaining amount of tokens that needs
to be bought by Pool. When it’s zero, a swap is done. <code class="language-plaintext highlighter-rouge">amountCalculated</code> is the out amount calculated by the contract–
it might not exactly match the amount specified by user due to slippage or incorrect calculations by user. <code class="language-plaintext highlighter-rouge">sqrtPriceX96</code>
and <code class="language-plaintext highlighter-rouge">tick</code> are new current price and tick after a swap is done.</p>

<p><code class="language-plaintext highlighter-rouge">StepState</code> maintains current swap step’s state. This structure tracks the state of <strong>one iteration</strong> of “order execution”.
<code class="language-plaintext highlighter-rouge">sqrtPriceStartX96</code> tracks the price the iteration begins with. <code class="language-plaintext highlighter-rouge">nextTick</code> is the next initialized tick that will provide
liquidity for the swap and <code class="language-plaintext highlighter-rouge">sqrtPriceNextX96</code> is the price at the next tick. <code class="language-plaintext highlighter-rouge">amountIn</code> and <code class="language-plaintext highlighter-rouge">amountOut</code> are amounts that
can be provided by the liquidity of the current iteration.</p>

<blockquote>
  <p>After we implement multi-range swaps (that is, swaps that happen across multiple price ranges), the idea of iterating
will be clearer.</p>
</blockquote>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="n">Slot0</span> <span class="k">memory</span> <span class="n">slot0_</span> <span class="o">=</span> <span class="n">slot0</span><span class="p">;</span>

<span class="n">SwapState</span> <span class="k">memory</span> <span class="n">state</span> <span class="o">=</span> <span class="n">SwapState</span><span class="p">({</span>
    <span class="n">amountSpecifiedRemaining</span><span class="o">:</span> <span class="n">amountSpecified</span><span class="p">,</span>
    <span class="n">amountCalculated</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="n">slot0_</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="n">tick</span><span class="o">:</span> <span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span>
<span class="p">});</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Before filling an order, we initialize a <code class="language-plaintext highlighter-rouge">SwapState</code> instance. We’ll loop until <code class="language-plaintext highlighter-rouge">amountSpecifiedRemaining</code> is 0, which
will mean that the pool has enough liquidity to buy <code class="language-plaintext highlighter-rouge">amountSpecified</code> tokens from user.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">amountSpecifiedRemaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">StepState</span> <span class="k">memory</span> <span class="n">step</span><span class="p">;</span>

    <span class="n">step</span><span class="p">.</span><span class="n">sqrtPriceStartX96</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">;</span>

    <span class="p">(</span><span class="n">step</span><span class="p">.</span><span class="n">nextTick</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">tickBitmap</span><span class="p">.</span><span class="n">nextInitializedTickWithinOneWord</span><span class="p">(</span>
        <span class="n">state</span><span class="p">.</span><span class="n">tick</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">zeroForOne</span>
    <span class="p">);</span>

    <span class="n">step</span><span class="p">.</span><span class="n">sqrtPriceNextX96</span> <span class="o">=</span> <span class="n">TickMath</span><span class="p">.</span><span class="n">getSqrtRatioAtTick</span><span class="p">(</span><span class="n">step</span><span class="p">.</span><span class="n">nextTick</span><span class="p">);</span>
</code></pre></div></div>

<p>In the loop, we set up a price range that should provide liquidity for the swap. The range is from <code class="language-plaintext highlighter-rouge">state.sqrtPriceX96</code>
to <code class="language-plaintext highlighter-rouge">step.sqrtPriceNextX96</code>, where the latter is the price at the next initialized tick (as returned by
<code class="language-plaintext highlighter-rouge">nextInitializedTickWithinOneWord</code>–we know this function from a previous chapter).</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">step</span><span class="p">.</span><span class="n">amountIn</span><span class="p">,</span> <span class="n">step</span><span class="p">.</span><span class="n">amountOut</span><span class="p">)</span> <span class="o">=</span> <span class="n">SwapMath</span>
    <span class="p">.</span><span class="n">computeSwapStep</span><span class="p">(</span>
        <span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span>
        <span class="n">step</span><span class="p">.</span><span class="n">sqrtPriceNextX96</span><span class="p">,</span>
        <span class="n">liquidity</span><span class="p">,</span>
        <span class="n">state</span><span class="p">.</span><span class="n">amountSpecifiedRemaining</span>
    <span class="p">);</span>
</code></pre></div></div>

<p>Next, we’re calculating the amounts that can be provider by current price range, and the new current price the swap
will result in.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">state</span><span class="p">.</span><span class="n">amountSpecifiedRemaining</span> <span class="o">-=</span> <span class="n">step</span><span class="p">.</span><span class="n">amountIn</span><span class="p">;</span>
    <span class="n">state</span><span class="p">.</span><span class="n">amountCalculated</span> <span class="o">+=</span> <span class="n">step</span><span class="p">.</span><span class="n">amountOut</span><span class="p">;</span>
    <span class="n">state</span><span class="p">.</span><span class="n">tick</span> <span class="o">=</span> <span class="n">TickMath</span><span class="p">.</span><span class="n">getTickAtSqrtRatio</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Final steps in the loop is updating the SwapState. <code class="language-plaintext highlighter-rouge">step.amountIn</code> is the amount of tokens the price range can buy
from user; <code class="language-plaintext highlighter-rouge">step.amountOut</code> is the related number of the other token the pool can sell to user. <code class="language-plaintext highlighter-rouge">state.sqrtPriceX96</code> is
the current price that will be set after the swap (recall that trading changes current price).</p>

<h2 id="swapmath-contract">SwapMath Contract</h2>

<p>Let’s look closer at <code class="language-plaintext highlighter-rouge">SwapMath.computeSwapStep</code>.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/SwapMath.sol
</span><span class="k">function</span> <span class="n">computeSwapStep</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceTargetX96</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amountRemaining</span>
<span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">pure</span>
    <span class="k">returns</span> <span class="p">(</span>
        <span class="kt">uint160</span> <span class="n">sqrtPriceNextX96</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">amountIn</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="n">amountOut</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>This is the core logic of swapping. The function calculates input and amount amounts of a swap within a price range and
respecting available liquidity.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">zeroForOne</span> <span class="o">=</span> <span class="n">sqrtPriceCurrentX96</span> <span class="o">&gt;=</span> <span class="n">sqrtPriceTargetX96</span><span class="p">;</span>

<span class="n">sqrtPriceNextX96</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">getNextSqrtPriceFromInput</span><span class="p">(</span>
    <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
    <span class="n">liquidity</span><span class="p">,</span>
    <span class="n">amountRemaining</span><span class="p">,</span>
    <span class="n">zeroForOne</span>
<span class="p">);</span>
</code></pre></div></div>

<p>By checking the price, we can determine the direction of the swap. Knowing the direction, we can calculate the price after
swapping <code class="language-plaintext highlighter-rouge">amountRemaining</code> of tokens. We’ll return to this function below.</p>

<p>After finding the new price, we can calculate input and output amounts of the swap. We’re recalculating <code class="language-plaintext highlighter-rouge">amountIn</code> (it
replaces <code class="language-plaintext highlighter-rouge">amountRemaining</code>) because <code class="language-plaintext highlighter-rouge">amountRemaining</code> is provided by user and it can be not accurate (and it can be
affected by slippage):</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">amountIn</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount0Delta</span><span class="p">(</span>
    <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
    <span class="n">sqrtPriceNextX96</span><span class="p">,</span>
    <span class="n">liquidity</span>
<span class="p">);</span>
<span class="n">amountOut</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount1Delta</span><span class="p">(</span>
    <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
    <span class="n">sqrtPriceNextX96</span><span class="p">,</span>
    <span class="n">liquidity</span>
<span class="p">);</span>
</code></pre></div></div>

<p>And swap the amounts if the direction is opposite:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zeroForOne</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">amountIn</span><span class="p">,</span> <span class="n">amountOut</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">amountOut</span><span class="p">,</span> <span class="n">amountIn</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s it for <code class="language-plaintext highlighter-rouge">computeSwapStep</code>!</p>

<h2 id="finding-price-by-swap-amount">Finding Price by Swap Amount</h2>

<p>Let’s now look at <code class="language-plaintext highlighter-rouge">Math.getNextSqrtPriceFromInput</code>–the function calculates a $\sqrt{P}$ given another $\sqrt{P}$,
liquidity, and input amount. It tells what the price will be after swapping the specified input amount of tokens, given
the current price and liquidity.</p>

<p>Good news is that we already know the formulas: recall how we calculated <code class="language-plaintext highlighter-rouge">price_next</code> in Python:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># When amount_in is token0
</span><span class="n">price_next</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">liq</span> <span class="o">*</span> <span class="n">q96</span> <span class="o">*</span> <span class="n">sqrtp_cur</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">liq</span> <span class="o">*</span> <span class="n">q96</span> <span class="o">+</span> <span class="n">amount_in</span> <span class="o">*</span> <span class="n">sqrtp_cur</span><span class="p">))</span>
<span class="c1"># When amount_in is token1
</span><span class="n">price_next</span> <span class="o">=</span> <span class="n">sqrtp_cur</span> <span class="o">+</span> <span class="p">(</span><span class="n">amount_in</span> <span class="o">*</span> <span class="n">q96</span><span class="p">)</span> <span class="o">//</span> <span class="n">liq</span>
</code></pre></div></div>

<p>We’re going to implement this in Solidity:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Math.sol
</span><span class="k">function</span> <span class="n">getNextSqrtPriceFromInput</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amountIn</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">zeroForOne</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint160</span> <span class="n">sqrtPriceNextX96</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sqrtPriceNextX96</span> <span class="o">=</span> <span class="n">zeroForOne</span>
        <span class="o">?</span> <span class="n">getNextSqrtPriceFromAmount0RoundingUp</span><span class="p">(</span>
            <span class="n">sqrtPriceX96</span><span class="p">,</span>
            <span class="n">liquidity</span><span class="p">,</span>
            <span class="n">amountIn</span>
        <span class="p">)</span>
        <span class="o">:</span> <span class="n">getNextSqrtPriceFromAmount1RoundingDown</span><span class="p">(</span>
            <span class="n">sqrtPriceX96</span><span class="p">,</span>
            <span class="n">liquidity</span><span class="p">,</span>
            <span class="n">amountIn</span>
        <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function handles swapping in both directions.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getNextSqrtPriceFromAmount0RoundingUp</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amountIn</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint160</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="n">numerator</span> <span class="o">=</span> <span class="kt">uint256</span><span class="p">(</span><span class="n">liquidity</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">FixedPoint96</span><span class="p">.</span><span class="n">RESOLUTION</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">product</span> <span class="o">=</span> <span class="n">amountIn</span> <span class="o">*</span> <span class="n">sqrtPriceX96</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">/</span> <span class="n">amountIn</span> <span class="o">==</span> <span class="n">sqrtPriceX96</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint256</span> <span class="n">denominator</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">+</span> <span class="n">product</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">denominator</span> <span class="o">&gt;=</span> <span class="n">numerator</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span>
                <span class="kt">uint160</span><span class="p">(</span>
                    <span class="n">mulDivRoundingUp</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span>
                <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span>
        <span class="kt">uint160</span><span class="p">(</span>
            <span class="n">divRoundingUp</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">sqrtPriceX96</span><span class="p">)</span> <span class="o">+</span> <span class="n">amountIn</span><span class="p">)</span>
        <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this function, we’re implementing two formulas. At the first <code class="language-plaintext highlighter-rouge">return</code>, it implements the same formula we implemented
in Python. This is the most precise formula, but it can overflow when multiplying <code class="language-plaintext highlighter-rouge">amountIn</code> by <code class="language-plaintext highlighter-rouge">sqrtPriceX96</code>. The
formula is (we discussed it in “Output Amount Calculation”):
\(\sqrt{P_{target}} = \frac{\sqrt{P}L}{\Delta x \sqrt{P} + L}\)</p>

<p>When it overflows, we use an alternative formula which is less precise:
\(\sqrt{P_{target}} = \frac{L}{\Delta x + \frac{L}{\sqrt{P}}}\)</p>

<p>Which is simply the previous formula with numerator and denominator divided by $\sqrt{P}$ to get rid of the multiplication.</p>

<p>The other function has simpler math:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getNextSqrtPriceFromAmount1RoundingDown</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amountIn</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint160</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>
        <span class="n">sqrtPriceX96</span> <span class="o">+</span>
        <span class="kt">uint160</span><span class="p">((</span><span class="n">amountIn</span> <span class="o">&lt;&lt;</span> <span class="n">FixedPoint96</span><span class="p">.</span><span class="n">RESOLUTION</span><span class="p">)</span> <span class="o">/</span> <span class="n">liquidity</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="finishing-the-swap">Finishing the Swap</h2>

<p>Let’s finish <code class="language-plaintext highlighter-rouge">swap</code> function. By this moment, we have looped over next initialized ticks, filled <code class="language-plaintext highlighter-rouge">amountSpecified</code>
specified by user, calculated input and amount amounts, and found new price and tick. We now need to update contract’s
state, send tokens to user, and get tokens in exchange.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">tick</span> <span class="o">!=</span> <span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">slot0</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">slot0</span><span class="p">.</span><span class="n">tick</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">tick</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>First, we set new price and tick. Since this operation writes to contract’s storage, we want to do it only if the new
tick is different, to optimize gas consumption.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">amount0</span><span class="p">,</span> <span class="n">amount1</span><span class="p">)</span> <span class="o">=</span> <span class="n">zeroForOne</span>
    <span class="o">?</span> <span class="p">(</span>
        <span class="kt">int256</span><span class="p">(</span><span class="n">amountSpecified</span> <span class="o">-</span> <span class="n">state</span><span class="p">.</span><span class="n">amountSpecifiedRemaining</span><span class="p">),</span>
        <span class="o">-</span><span class="kt">int256</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">amountCalculated</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="o">:</span> <span class="p">(</span>
        <span class="o">-</span><span class="kt">int256</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">amountCalculated</span><span class="p">),</span>
        <span class="kt">int256</span><span class="p">(</span><span class="n">amountSpecified</span> <span class="o">-</span> <span class="n">state</span><span class="p">.</span><span class="n">amountSpecifiedRemaining</span><span class="p">)</span>
    <span class="p">);</span>
</code></pre></div></div>

<p>Next, we calculate swap amounts based on swap direction and the amounts calculated during the swap loop.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">zeroForOne</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IERC20</span><span class="p">(</span><span class="n">token1</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">(</span><span class="o">-</span><span class="n">amount1</span><span class="p">));</span>

    <span class="kt">uint256</span> <span class="n">balance0Before</span> <span class="o">=</span> <span class="n">balance0</span><span class="p">();</span>
    <span class="n">IUniswapV3SwapCallback</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">).</span><span class="n">uniswapV3SwapCallback</span><span class="p">(</span>
        <span class="n">amount0</span><span class="p">,</span>
        <span class="n">amount1</span><span class="p">,</span>
        <span class="n">data</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance0Before</span> <span class="o">+</span> <span class="kt">uint256</span><span class="p">(</span><span class="n">amount0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">balance0</span><span class="p">())</span>
        <span class="nb">revert</span> <span class="n">InsufficientInputAmount</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">IERC20</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">(</span><span class="o">-</span><span class="n">amount0</span><span class="p">));</span>

    <span class="kt">uint256</span> <span class="n">balance1Before</span> <span class="o">=</span> <span class="n">balance1</span><span class="p">();</span>
    <span class="n">IUniswapV3SwapCallback</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">).</span><span class="n">uniswapV3SwapCallback</span><span class="p">(</span>
        <span class="n">amount0</span><span class="p">,</span>
        <span class="n">amount1</span><span class="p">,</span>
        <span class="n">data</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">balance1Before</span> <span class="o">+</span> <span class="kt">uint256</span><span class="p">(</span><span class="n">amount1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">balance1</span><span class="p">())</span>
        <span class="nb">revert</span> <span class="n">InsufficientInputAmount</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next, we’re exchanging tokens with user, depending on swap direction. This piece is identical to what we had in Milestone 2,
only handling of the other swap direction was added.</p>

<p>That’s it! Swapping is done!</p>

<h2 id="testing">Testing</h2>

<p>Test won’t change significantly, we only need to pass <code class="language-plaintext highlighter-rouge">amountSpecified</code> and <code class="language-plaintext highlighter-rouge">zeroForOne</code> to <code class="language-plaintext highlighter-rouge">swap</code> function. Output amount
will change insignificantly though, because it’s now calculated in Solidity.</p>

<p>We can now test swapping in the opposite direction! I’ll leave this for you, as a homework (just be sure to choose a
small input amount so the whole swap can be handled by our single price range).</p>
