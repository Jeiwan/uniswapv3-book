
<h1 id="generalize-minting">Generalize Minting</h1>

<p>Now, we’re ready to update <code class="language-plaintext highlighter-rouge">mint</code> function so it calculates the amounts of tokens instead of hard coding them.</p>

<h2 id="indexing-initialized-ticks">Indexing Initialized Ticks</h2>

<p>Recall that, in <code class="language-plaintext highlighter-rouge">mint</code> function, we update the TickInfo mapping to store information about available liquidity at ticks.
Now, we also need to index newly initialized ticks in the bitmap index–we’ll later use this index to find next initialized
tick during swapping.</p>

<p>First, we need to update <code class="language-plaintext highlighter-rouge">Tick.update</code> function:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Tick.sol
</span><span class="k">function</span> <span class="n">update</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidityDelta</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">flipped</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">flipped</span> <span class="o">=</span> <span class="p">(</span><span class="n">liquidityAfter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">liquidityBefore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It now returns <code class="language-plaintext highlighter-rouge">flipped</code> flag, which is set to true when liquidity is added to an empty tick or when entire liquidity
is removed from a tick.</p>

<p>Then, in <code class="language-plaintext highlighter-rouge">mint</code> function, we update the bitmap index:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Pool.sol
</span><span class="p">...</span>
<span class="kt">bool</span> <span class="n">flippedLower</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">lowerTick</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">flippedUpper</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">upperTick</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">flippedLower</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tickBitmap</span><span class="p">.</span><span class="n">flipTick</span><span class="p">(</span><span class="n">lowerTick</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">flippedUpper</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tickBitmap</span><span class="p">.</span><span class="n">flipTick</span><span class="p">(</span><span class="n">upperTick</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<blockquote>
  <p>Again, we’re setting tick spacing to 1 until we introduce different values in Milestone 3.</p>
</blockquote>

<h2 id="token-amounts-calculation">Token Amounts Calculation</h2>

<p>The biggest change in <code class="language-plaintext highlighter-rouge">mint</code> function is switching to tokens amount calculation. In Milestone 1, we hard coded these
values:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">amount0</span> <span class="o">=</span> <span class="mf">0.998976618347425280</span> <span class="kc">ether</span><span class="p">;</span>
    <span class="n">amount1</span> <span class="o">=</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">;</span>
</code></pre></div></div>

<p>And now we’re going to calculate them in Solidity using formulas from Milestone 1. Let’s recall those formulas:</p>

<p>\(\Delta x = \frac{L(\sqrt{p(i_u)} - \sqrt{p(i_c)})}{\sqrt{p(i_u)}\sqrt{p(i_c)}}\)
\(\Delta y = L(\sqrt{p(i_c)} - \sqrt{p(i_l)})\)</p>

<p>$\Delta x$ is the amount of <code class="language-plaintext highlighter-rouge">token0</code>, or token $X$. Let’s implement it in Solidity:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Math.sol
</span><span class="k">function</span> <span class="n">calcAmount0Delta</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceAX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceBX96</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidity</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">amount0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceAX96</span> <span class="o">&gt;</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sqrtPriceAX96</span><span class="p">,</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtPriceBX96</span><span class="p">,</span> <span class="n">sqrtPriceAX96</span><span class="p">);</span>

    <span class="nb">require</span><span class="p">(</span><span class="n">sqrtPriceAX96</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">amount0</span> <span class="o">=</span> <span class="n">divRoundingUp</span><span class="p">(</span>
        <span class="n">mulDivRoundingUp</span><span class="p">(</span>
            <span class="p">(</span><span class="kt">uint256</span><span class="p">(</span><span class="n">liquidity</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">FixedPoint96</span><span class="p">.</span><span class="n">RESOLUTION</span><span class="p">),</span>
            <span class="p">(</span><span class="n">sqrtPriceBX96</span> <span class="o">-</span> <span class="n">sqrtPriceAX96</span><span class="p">),</span>
            <span class="n">sqrtPriceBX96</span>
        <span class="p">),</span>
        <span class="n">sqrtPriceAX96</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>This function is identical to <code class="language-plaintext highlighter-rouge">calc_amount0</code> in our Python script.</p>
</blockquote>

<p>First step is to sort the prices to ensure we don’t underflow when subtracting. Next, we convert <code class="language-plaintext highlighter-rouge">liquidity</code> to a Q96.64
number by multiplying it by 2**96. Next, according to the formula, we multiply it by the difference of the prices and
divide it by the bigger price. Then, we divide by the smaller price. The order of division doesn’t matter, but we want
to have two divisions because multiplication of prices can overflow.</p>

<p>We’re using <code class="language-plaintext highlighter-rouge">mulDivRoundingUp</code> to multiply and divide in one operation. This function is based on <code class="language-plaintext highlighter-rouge">mulDiv</code> from <code class="language-plaintext highlighter-rouge">PRBMath</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">mulDivRoundingUp</span><span class="p">(</span>
    <span class="kt">uint256</span> <span class="n">a</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">b</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">denominator</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">denominator</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">mulmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">denominator</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="k">type</span><span class="p">(</span><span class="kt">uint256</span><span class="p">).</span><span class="n">max</span><span class="p">);</span>
        <span class="n">result</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mulmod</code> is a Solidity function that multiplies two numbers (<code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>), divides the result by <code class="language-plaintext highlighter-rouge">denominator</code>, and 
returns the remainder. If the remainder is positive, we round the result up.</p>

<blockquote>
  <p>We always round calculated amounts up because we haven’t implement liquidity removal yet. We adding liquidity, we want
to ensure that calculated token amounts “fill” the entire liquidity.</p>
</blockquote>

<p>Next, $\Delta y$:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">calcAmount1Delta</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceAX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceBX96</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidity</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">amount1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceAX96</span> <span class="o">&gt;</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sqrtPriceAX96</span><span class="p">,</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtPriceBX96</span><span class="p">,</span> <span class="n">sqrtPriceAX96</span><span class="p">);</span>

    <span class="n">amount1</span> <span class="o">=</span> <span class="n">mulDivRoundingUp</span><span class="p">(</span>
        <span class="n">liquidity</span><span class="p">,</span>
        <span class="p">(</span><span class="n">sqrtPriceBX96</span> <span class="o">-</span> <span class="n">sqrtPriceAX96</span><span class="p">),</span>
        <span class="n">FixedPoint96</span><span class="p">.</span><span class="n">Q96</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>This function is identical to <code class="language-plaintext highlighter-rouge">calc_amount1</code> in our Python script.</p>
</blockquote>

<p>Again, we’re using <code class="language-plaintext highlighter-rouge">mulDivRoundingUp</code> to avoid overflows during multiplication.</p>

<p>And that’s it! We can now use the functions to calculate token amounts:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Pool.sol
</span><span class="k">function</span> <span class="n">mint</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">Slot0</span> <span class="k">memory</span> <span class="n">slot0_</span> <span class="o">=</span> <span class="n">slot0</span><span class="p">;</span>

    <span class="n">amount0</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount0Delta</span><span class="p">(</span>
        <span class="n">TickMath</span><span class="p">.</span><span class="n">getSqrtRatioAtTick</span><span class="p">(</span><span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span><span class="p">),</span>
        <span class="n">TickMath</span><span class="p">.</span><span class="n">getSqrtRatioAtTick</span><span class="p">(</span><span class="n">upperTick</span><span class="p">),</span>
        <span class="n">amount</span>
    <span class="p">);</span>

    <span class="n">amount1</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount1Delta</span><span class="p">(</span>
        <span class="n">TickMath</span><span class="p">.</span><span class="n">getSqrtRatioAtTick</span><span class="p">(</span><span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span><span class="p">),</span>
        <span class="n">TickMath</span><span class="p">.</span><span class="n">getSqrtRatioAtTick</span><span class="p">(</span><span class="n">lowerTick</span><span class="p">),</span>
        <span class="n">amount</span>
    <span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything else remains the same. You’ll need to update the amounts in the pool tests, they’ll be slightly different
due to rounding.</p>
