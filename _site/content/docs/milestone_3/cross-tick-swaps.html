
<h1 id="cross-tick-swaps">Cross-Tick Swaps</h1>

<p>Cross-tick swaps is probably the most advanced feature of Uniswap V3. Luckily, we have already implemented almost everything
we need to make cross-tick swaps. Let’s review how swapping works in our current implementation.</p>

<h2 id="how-cross-tick-swaps-work">How Cross-Tick Swaps Work</h2>

<p>Let’s recap how cross-tick swaps work before getting down to code.</p>

<p>[TODO: illustrate a pool with multiple price ranges]</p>

<p>A common Uniswap V3 pool is a pool with many overlapping (and outstanding) price ranges. Each pool tracks current $\sqrt{P}$
and tick. When users swap tokens they move current price and tick to the left or to the right of the current ones,
depending on swap direction. These movements are caused by liquidity being added and removed from pools during swaps.</p>

<p>Pools also track $L$ (<code class="language-plaintext highlighter-rouge">liquidity</code> variable in our code), which is <strong>the sum of liquidity provided by all price ranges
that include current price</strong>. It’s expected that, during big price moves, current price moves outside of price ranges.
When this happens, such price ranges become inactive and their liquidity gets subtracted from $L$. On the other hand,
when current price enters a price range, $L$ is increased and the price range gets activated.</p>

<p>Our current implementation doesn’t support such fluidity: we only allow swaps within one active price range. This is what
we’re going to fix.</p>

<h2 id="updating-computeswapstep-function">Updating <code class="language-plaintext highlighter-rouge">computeSwapStep</code> Function</h2>

<p>In <code class="language-plaintext highlighter-rouge">swap</code> function, we’re iterating over initialized ticks (that is, ticks with liquidity) to fill the amount user has
requested. In each iteration, we:</p>

<ol>
  <li>find next initialized tick using <code class="language-plaintext highlighter-rouge">tickBitmap.nextInitializedTickWithinOneWord</code>;</li>
  <li>swapping in the range between the current price and the next initialized tick (using <code class="language-plaintext highlighter-rouge">SwapMath.computeSwapStep</code>);</li>
  <li>always expect that current liquidity is enough to satisfy the swap (i.e. the price after swap is between the current
price and the next initialized tick).</li>
</ol>

<p>But what happens if the third step is not true? We have this scenario covered in tests:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// test/UniswapV3Pool.t.sol
</span><span class="k">function</span> <span class="n">testSwapBuyEthNotEnoughLiquidity</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="kt">uint256</span> <span class="n">swapAmount</span> <span class="o">=</span> <span class="mi">5300</span> <span class="kc">ether</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="n">vm</span><span class="p">.</span><span class="n">expectRevert</span><span class="p">(</span><span class="n">stdError</span><span class="p">.</span><span class="n">arithmeticError</span><span class="p">);</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">swapAmount</span><span class="p">,</span> <span class="n">extra</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The “Arithmetic over/underflow” happens when trying to transfer an amount that’s too big (not approved by user). This
happens because, when calculating a swap step, we always expect that next initialized tick always have enough liquidity
to satisfy the swap:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/SwapMath.sol
</span><span class="k">function</span> <span class="n">computeSwapStep</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">sqrtPriceNextX96</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">getNextSqrtPriceFromInput</span><span class="p">(</span>
        <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
        <span class="n">liquidity</span><span class="p">,</span>
        <span class="n">amountRemaining</span><span class="p">,</span>
        <span class="n">zeroForOne</span>
    <span class="p">);</span>

    <span class="n">amountIn</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">amountOut</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To fix this, we need to pre-calculate the output amount and compare it with the amount requested (<code class="language-plaintext highlighter-rouge">amountRemaining</code>): if
it’s smaller, then the next initialized tick doesn’t have enough liquidity. If it’s equal to <code class="language-plaintext highlighter-rouge">amountRemaining</code>, then it’s
safe to assume that the next initialized tick has enough liquidity.</p>

<p>Here’s how to fix it:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/SwapMath.sol
</span><span class="k">function</span> <span class="n">computeSwapStep</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">amountIn</span> <span class="o">=</span> <span class="n">zeroForOne</span>
        <span class="o">?</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount0Delta</span><span class="p">(</span>
            <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
            <span class="n">sqrtPriceTargetX96</span><span class="p">,</span>
            <span class="n">liquidity</span>
        <span class="p">)</span>
        <span class="o">:</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount1Delta</span><span class="p">(</span>
            <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
            <span class="n">sqrtPriceTargetX96</span><span class="p">,</span>
            <span class="n">liquidity</span>
        <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amountRemaining</span> <span class="o">&gt;=</span> <span class="n">amountIn</span><span class="p">)</span> <span class="n">sqrtPriceNextX96</span> <span class="o">=</span> <span class="n">sqrtPriceTargetX96</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">sqrtPriceNextX96</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">getNextSqrtPriceFromInput</span><span class="p">(</span>
            <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
            <span class="n">liquidity</span><span class="p">,</span>
            <span class="n">amountRemaining</span><span class="p">,</span>
            <span class="n">zeroForOne</span>
        <span class="p">);</span>

    <span class="n">amountIn</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount0Delta</span><span class="p">(</span>
        <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
        <span class="n">sqrtPriceNextX96</span><span class="p">,</span>
        <span class="n">liquidity</span>
    <span class="p">);</span>
    <span class="n">amountOut</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount1Delta</span><span class="p">(</span>
        <span class="n">sqrtPriceCurrentX96</span><span class="p">,</span>
        <span class="n">sqrtPriceNextX96</span><span class="p">,</span>
        <span class="n">liquidity</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We first pre-calculate <code class="language-plaintext highlighter-rouge">amountIn</code> depending on swap direction. Then, we check if this amount is enough to satisfy the
swap: if so, we’re calculating $\sqrt{P}$ of the new price; if not, we’re calculating only the amounts that can be provided
by this price range–on the next iteration, we’ll try to fill the remaining amount.</p>

<p>I hope this makes sense!</p>

<h2 id="updating-swap-function">Updating <code class="language-plaintext highlighter-rouge">swap</code> Function</h2>

<p>Now, in <code class="language-plaintext highlighter-rouge">swap</code> function, we need to handle the case we introduced in the previous part: when swap price reaches a boundary
of a price range. When this happens, we want to deactivate the price range we’re leaving and active the next price range.
We also want to start the next iteration of the loop with the initialized tick we found in this loop.</p>

<p>Here’s what we need to add to the end of the loop:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span> <span class="o">==</span> <span class="n">step</span><span class="p">.</span><span class="n">sqrtPriceNextX96</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int128</span> <span class="n">liquidityDelta</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span><span class="n">step</span><span class="p">.</span><span class="n">nextTick</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">zeroForOne</span><span class="p">)</span> <span class="n">liquidityDelta</span> <span class="o">=</span> <span class="o">-</span><span class="n">liquidityDelta</span><span class="p">;</span>

    <span class="n">state</span><span class="p">.</span><span class="n">liquidity</span> <span class="o">=</span> <span class="n">LiquidityMath</span><span class="p">.</span><span class="n">addLiquidity</span><span class="p">(</span>
        <span class="n">state</span><span class="p">.</span><span class="n">liquidity</span><span class="p">,</span>
        <span class="n">liquidityDelta</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">liquidity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="nb">revert</span> <span class="n">NotEnoughLiquidity</span><span class="p">();</span>

    <span class="n">state</span><span class="p">.</span><span class="n">tick</span> <span class="o">=</span> <span class="n">zeroForOne</span> <span class="o">?</span> <span class="n">step</span><span class="p">.</span><span class="n">nextTick</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">step</span><span class="p">.</span><span class="n">nextTick</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">.</span><span class="n">tick</span> <span class="o">=</span> <span class="n">TickMath</span><span class="p">.</span><span class="n">getTickAtSqrtRatio</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The second branch is what we had before–it handles the case when current price stays within the range. So let’s focus on
the first one.</p>

<p><code class="language-plaintext highlighter-rouge">state.sqrtPriceX96</code> is updated current price, i.e. the price that will be set after the current swap; <code class="language-plaintext highlighter-rouge">step.sqrtPriceNextX96</code>
is the price at the next initialized tick. If these are equal, we have reached a price range boundary. As discussed above,
when this happens, we want to update $L$ (add or remove liquidity) and continue the swap using the boundary tick as the
current tick.</p>

<p>For convenience, crossing a tick means crossing it from left to right. Thus, lower ticks always add liquidity and upper
ticks always remove it. However, when <code class="language-plaintext highlighter-rouge">zeroForOne</code> is true, we negate the sign: when price goes down (token $X$ is being
sold), upper ticks add liquidity and lower ticks remove it.</p>

<p>When updating <code class="language-plaintext highlighter-rouge">state.tick</code>, if price moves down (<code class="language-plaintext highlighter-rouge">zeroForOne</code> is true), we need to subtract 1 to step out of the price
range. When moving up (<code class="language-plaintext highlighter-rouge">zeroForOne</code> is false), current tick is always excluded in <code class="language-plaintext highlighter-rouge">TickBitmap.nextInitializedTickWithinOneWord</code>.</p>

<p>Another small, but very important, change that we need to make is to update $L$ when swapping caused ticks crossing:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">liquidity_</span> <span class="o">!=</span> <span class="n">state</span><span class="p">.</span><span class="n">liquidity</span><span class="p">)</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">liquidity</span><span class="p">;</span>
</code></pre></div></div>

<p>We do this after the loop.</p>

<h2 id="liquidity-tracking-and-ticks-crossing">Liquidity Tracking and Ticks Crossing</h2>

<p>Let’s now look at updated <code class="language-plaintext highlighter-rouge">Tick</code> library.</p>

<p>First change is in <code class="language-plaintext highlighter-rouge">Tick.Info</code> structure: we now have two variables to track tick liquidity:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Info</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">initialized</span><span class="p">;</span>
    <span class="c1">// total liquidity at tick
</span>    <span class="kt">uint128</span> <span class="n">liquidityGross</span><span class="p">;</span>
    <span class="c1">// amount of liqudiity added or subtracted when tick is crossed
</span>    <span class="kt">int128</span> <span class="n">liquidityNet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">liquidityGross</code> tracks the absolute liquidity amount of a tick. It’s needed to find if tick was flipped or not. <code class="language-plaintext highlighter-rouge">liquidityNet</code>,
on the other hand, is a signed integer–it tracks the amount of liquidity added (in case of lower tick) or removed
(in case of upper tick) when a tick is crossed.</p>

<p><code class="language-plaintext highlighter-rouge">liquidityNet</code> is set in <code class="language-plaintext highlighter-rouge">update</code> function:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">update</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">int128</span> <span class="n">liquidityDelta</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">upper</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">flipped</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">tickInfo</span><span class="p">.</span><span class="n">liquidityNet</span> <span class="o">=</span> <span class="n">upper</span>
        <span class="o">?</span> <span class="kt">int128</span><span class="p">(</span><span class="kt">int256</span><span class="p">(</span><span class="n">tickInfo</span><span class="p">.</span><span class="n">liquidityNet</span><span class="p">)</span> <span class="o">-</span> <span class="n">liquidityDelta</span><span class="p">)</span>
        <span class="o">:</span> <span class="kt">int128</span><span class="p">(</span><span class="kt">int256</span><span class="p">(</span><span class="n">tickInfo</span><span class="p">.</span><span class="n">liquidityNet</span><span class="p">)</span> <span class="o">+</span> <span class="n">liquidityDelta</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">cross</code> function we saw above simply returns <code class="language-plaintext highlighter-rouge">liquidityNet</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">cross</span><span class="p">(</span><span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int24</span> <span class="n">tick</span><span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">view</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">int128</span> <span class="n">liquidityDelta</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">info</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">tick</span><span class="p">];</span>
    <span class="n">liquidityDelta</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">liquidityNet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="testing">Testing</h2>

<p>Let’s review different liquidity setups and test them to ensure our pool implementation can handle them correctly.</p>

<h3 id="one-price-range">One Price Range</h3>

<p>[TODO: illustrate one price range with current price]</p>

<p>This is the scenario we had earlier. After we have updated the code, we need to ensure old functionality keeps working
correctly.</p>

<blockquote>
  <p>For brevity, I’ll show only most important parts of the tests. You can find full tests in <a href="https://github.com/Jeiwan/uniswapv3-code/blob/milestone_3/test/UniswapV3Pool.Swaps.t.sol">the code repo</a>.</p>
</blockquote>

<ul>
  <li>When buying ETH:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyETHOnePriceRange</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4545</span><span class="p">,</span> <span class="mi">5500</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>

      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="o">-</span><span class="mf">0.008396874645169943</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">42</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">5604415652688968742392013927525</span><span class="p">,</span> <span class="c1">// 5003.8180249710795
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">85183</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>When buying USDC:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyUSDCOnePriceRange</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4545</span><span class="p">,</span> <span class="mi">5500</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>

      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="mf">0.01337</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="o">-</span><span class="mf">66.807123823853842027</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">5598737223630966236662554421688</span><span class="p">,</span> <span class="c1">// 4993.683362269102
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">85163</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>In both of these scenario we buy a small amount of EHT or USDC–it needs to be small enough for the price to not leave
the only price range we created. Key values after swapping is done:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">sqrtPriceX96</code> is slightly above or below the initial price and stays within the price rage;</li>
  <li><code class="language-plaintext highlighter-rouge">currentLiquidity</code> remains unchanged.</li>
</ol>

<blockquote>
  <p>In the theoretical Uniswap V3 introduction, we discussed that $L$ doesn’t change when swapping happens within a price
range. We now can see this in practice.</p>
</blockquote>

<h3 id="multiple-identical-and-overlapping-price-ranges">Multiple Identical and Overlapping Price Ranges</h3>

<p>[TODO: illustrate]</p>

<ul>
  <li>When buying ETH:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyETHTwoEqualPriceRanges</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span> <span class="k">memory</span> <span class="n">range</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span>
          <span class="mi">4545</span><span class="p">,</span>
          <span class="mi">5500</span><span class="p">,</span>
          <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">5000</span>
      <span class="p">);</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">range</span><span class="p">;</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">range</span><span class="p">;</span>

      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="o">-</span><span class="mf">0.008398516982770993</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">42</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">5603319704133145322707074461607</span><span class="p">,</span> <span class="c1">// 5001.861214026131
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">85179</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">amount</span> <span class="o">+</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>When buying USDC:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyUSDCTwoEqualPriceRanges</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span> <span class="k">memory</span> <span class="n">range</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span>
          <span class="mi">4545</span><span class="p">,</span>
          <span class="mi">5500</span><span class="p">,</span>
          <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">5000</span>
      <span class="p">);</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">range</span><span class="p">;</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">range</span><span class="p">;</span>
        
      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="mf">0.01337</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="o">-</span><span class="mf">66.827918929906650442</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">5600479946976371527693873969480</span><span class="p">,</span> <span class="c1">// 4996.792621611429
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">85169</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">amount</span> <span class="o">+</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>This scenario is similar to the previous one but this time we create two identical price ranges. Two moments are
important here:</p>
<ol>
  <li>Price impact is lower than in the previous scenario. The more liquidity the lower the price range.</li>
  <li>Current liquidity is the sum of the two price ranges. This is because both of them include the current price.</li>
</ol>

<p>Also, we get slightly more tokens thanks to deeper liquidity.</p>

<h3 id="consecutive-price-ranges">Consecutive Price Ranges</h3>

<p>[TODO: illustrate both scenarios]</p>

<ul>
  <li>When buying ETH:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyETHConsecutivePriceRanges</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4545</span><span class="p">,</span> <span class="mi">5500</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">5500</span><span class="p">,</span> <span class="mi">6250</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>

      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="o">-</span><span class="mf">1.820694594787485635</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">10000</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">6190476002219365604851182401841</span><span class="p">,</span> <span class="c1">// 6105.045728033458
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">87173</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>When buying USDC:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyUSDCConsecutivePriceRanges</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4545</span><span class="p">,</span> <span class="mi">5500</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="mi">4545</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
        
      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="mi">2</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="o">-</span><span class="mf">9103.264925902176327184</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">5069962753257045266417033265661</span><span class="p">,</span> <span class="c1">// 4094.9666586581643
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">83179</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>In these scenarios, we make big swaps that cause price to move outside of a price range. As a result, the second price
range gets activated and provides enough liquidity to satisfy the swap. In both scenarios, we can see that price lands
outside of the shorted price range and that the short price range gets deactivated (current liquidity equals to the
liquidity of the second price range).</p>

<h3 id="partially-overlapping-price-ranges">Partially Overlapping Price Ranges</h3>

<p>[TODO: illustrate both scenarios]</p>

<ul>
  <li>When buying ETH:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyETHPartiallyOverlappingPriceRanges</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4545</span><span class="p">,</span> <span class="mi">5500</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">5001</span><span class="p">,</span> <span class="mi">6250</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
        
      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="o">-</span><span class="mf">1.864220641170389178</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="mi">10000</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">6165345094827913637987008642386</span><span class="p">,</span> <span class="c1">// 6055.578153852725
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">87091</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>When buying USDC:
    <div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span> <span class="n">testBuyUSDCPartiallyOverlappingPriceRanges</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="n">LiquidityRange</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">liquidity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LiquidityRange</span><span class="p">[](</span><span class="mi">2</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4545</span><span class="p">,</span> <span class="mi">5500</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
      <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">liquidityRange</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="mi">4999</span><span class="p">,</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
        
      <span class="p">...</span>

      <span class="p">(</span><span class="kt">int256</span> <span class="n">expectedAmount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">expectedAmount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
          <span class="mi">2</span> <span class="kc">ether</span><span class="p">,</span>
          <span class="o">-</span><span class="mf">9321.077831210790476918</span> <span class="kc">ether</span>
      <span class="p">);</span>

      <span class="n">assertSwapState</span><span class="p">(</span>
          <span class="n">ExpectedStateAfterSwap</span><span class="p">({</span>
              <span class="p">...</span>
              <span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="mi">5090915820491052794734777344590</span><span class="p">,</span> <span class="c1">// 4128.883835866256
</span>              <span class="n">tick</span><span class="o">:</span> <span class="mi">83261</span><span class="p">,</span>
              <span class="n">currentLiquidity</span><span class="o">:</span> <span class="n">liquidity</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">amount</span>
          <span class="p">})</span>
      <span class="p">);</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>This is a variation of the previous scenario, but this time the price ranges are partially overlapping. In this scenario,
I used the same amounts, and, as a result of deeper liquidity in the overlapping area, price impact was lower: we got
more paying less, and the price changes were smaller.</p>
