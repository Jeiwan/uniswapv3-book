
<h1 id="a-little-bit-more-on-fixed-point-numbers">A Little Bit More on Fixed-point Numbers</h1>

<p>In this bonus chapter, I’d like to show you how to convert prices to ticks in Solidity. We don’t need to do this in the
main contracts, but it’s helpful to have such function in tests so we don’t hardcode ticks and could write something like
<code class="language-plaintext highlighter-rouge">tick(5000)</code>–this makes code easier to read because it’s more convenient for us to think in prices, not tick numbers.</p>

<p>Recall that, to find ticks, we use <code class="language-plaintext highlighter-rouge">TickMath.getTickAtSqrtRatio</code> function, which takes $\sqrt{P}$ as its argument, and
$\sqrt{P}$ in its turns is a Q64.96 fixed-point number. In smart contract tests, we need to check $\sqrt{P}$ many times
in many different test cases: mostly after mints and swaps. Instead of hard coding actual values, it might be cleaner to
use a helper function like <code class="language-plaintext highlighter-rouge">sqrtP(5000)</code> that converts prices to $\sqrt{P}$.</p>

<p>So, what’s the problem?</p>

<p>The problem is that Solidity doesn’t natively support the square root operation, which means we need a third-party
library. Another problem is that prices are often relatively small numbers, like 10, 5000, 0.01, etc., and we don’t want
to lose precision when taking square root.</p>

<p>You probably remember that we used <code class="language-plaintext highlighter-rouge">PRBMath</code> earlier in the book to implement multiply-then-divide operation that doesn’t
overflow during multiplication. If you check <code class="language-plaintext highlighter-rouge">PRBMath.sol</code> contract, you’ll notice <code class="language-plaintext highlighter-rouge">sqrt</code> function. However, the function
doesn’t support fixed-point numbers, as the function description points at. You can give it a try and see that
<code class="language-plaintext highlighter-rouge">PRBMath.sqrt(5000)</code> results in <code class="language-plaintext highlighter-rouge">70</code>, which is an integer number with lost precision (without the fractional part).</p>

<p>If you check <a href="https://github.com/paulrberg/prb-math">prb-math</a> repo, you’ll see these contracts: <code class="language-plaintext highlighter-rouge">PRBMathSD59x18.sol</code>
and <code class="language-plaintext highlighter-rouge">PRBMathUD60x18.sol</code>. Aha! These are fixed-point number implementations. Let’s pick the latter and see how it goes:
<code class="language-plaintext highlighter-rouge">PRBMathUD60x18.sqrt(5000 * PRBMathUD60x18.SCALE)</code> returns <code class="language-plaintext highlighter-rouge">70710678118654752440</code>. This looks interesting!
<code class="language-plaintext highlighter-rouge">PRBMathUD60x18</code> is a library that implements fixed-numbers with 18 decimal places in the fractional part. So the number
we got is actually 70.710678118654752440 (use <code class="language-plaintext highlighter-rouge">cast --from-wei 70710678118654752440</code>).</p>

<p>However! We cannot use this number!</p>

<p>There are fixed-point numbers and fixed-point numbers. The Q64.96 fixed-point number used by Uniswap V3 is a <strong>binary</strong>
number–64 and 96 signify <em>binary places</em>. But <code class="language-plaintext highlighter-rouge">PRBMathUD60x18</code> implements a <em>decimal</em> fixed-point number (UD in the
contract name means “unsigned, decimal”), where 60 and 18 signify <em>decimal places</em>. This difference is quite significant.</p>

<p>Let’s see how to convert an arbitrary number (42) to either of the above fixed-point numbers:</p>
<ol>
  <li>Q64.96: $42 * 2^{96}$ or, using bitwise left shift, <code class="language-plaintext highlighter-rouge">2 &lt;&lt; 96</code>. The result is 3327582825599102178928845914112.</li>
  <li>UD60.18: $42 * 10^{18}$. The result is 42000000000000000000.</li>
</ol>

<p>Let’s now see how to convert numbers with the fractional part (42.1337):</p>
<ol>
  <li>Q64.96: $421337 * 2^{92}$ or <code class="language-plaintext highlighter-rouge">421337 &lt;&lt; 92</code>. The result is 2086359769329537075540689212669952.</li>
  <li>UD60.18: $421337 * 10^{14}$. The result is 42133700000000000000.</li>
</ol>

<p>The second variant makes more sense to us because it uses the decimal system, which we learned in our childhood. The
first variant uses the binary system and it makes absolutely no sense.</p>

<p>But the biggest problem with different variants is that it’s hard to convert between them.</p>

<p>This all means that we need a different library, one that implements a binary fixed-point number and <code class="language-plaintext highlighter-rouge">sqrt</code> function for
it. Luckily, there’s such library: <a href="https://github.com/abdk-consulting/abdk-libraries-solidity">abdk-libraries-solidity</a>.
The library implemented Q64.64, not exactly what we need (not 96 bits in the fractional part) but this is not a problem.</p>

<p>Here’s how we can implement the price-to-tick function using the new library:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">tick</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">price</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">int24</span> <span class="n">tick_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tick_</span> <span class="o">=</span> <span class="n">TickMath</span><span class="p">.</span><span class="n">getTickAtSqrtRatio</span><span class="p">(</span>
        <span class="kt">uint160</span><span class="p">(</span>
            <span class="kt">int160</span><span class="p">(</span>
                <span class="n">ABDKMath64x64</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="kt">int128</span><span class="p">(</span><span class="kt">int256</span><span class="p">(</span><span class="n">price</span> <span class="o">&lt;&lt;</span> <span class="mi">64</span><span class="p">)))</span> <span class="o">&lt;&lt;</span>
                    <span class="p">(</span><span class="n">FixedPoint96</span><span class="p">.</span><span class="n">RESOLUTION</span> <span class="o">-</span> <span class="mi">64</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ABDKMath64x64.sqrt</code> takes Q64.64 numbers so we need to convert <code class="language-plaintext highlighter-rouge">price</code> to such number. The price is expected to not have the
fractional part, so we’re shifting it by 64 bits. The <code class="language-plaintext highlighter-rouge">sqrt</code> function also returns a Q64.64 number but <code class="language-plaintext highlighter-rouge">TickMath.getTickAtSqrtRatio</code>
takes a Q64.96 number–this is why we need to shift the square root by 96 - 64 bits to the left.</p>
