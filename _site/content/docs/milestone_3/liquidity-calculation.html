
<h1 id="liquidity-calculation">Liquidity Calculation</h1>

<p>Of the whole math of Uniswap V3, what we haven&#8217;t yet implemented in Solidity is liquidity calculation. In the Python
script, we have these functions:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">liquidity0</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pa</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="p">:</span>
        <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pa</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">amount</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span> <span class="o">*</span> <span class="n">pb</span><span class="p">)</span> <span class="o">/</span> <span class="n">q96</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">liquidity1</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pa</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="p">:</span>
        <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pa</span>
    <span class="k">return</span> <span class="n">amount</span> <span class="o">*</span> <span class="n">q96</span> <span class="o">/</span> <span class="p">(</span><span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span>
</code></pre></div></div>

<p>Let&#8217;s implement them in Solidity so we could calculate liquidity in <code class="language-plaintext highlighter-rouge">Manager.mint</code> function.</p>

<h2 id="implementing-liquidity-calculation-for-token-x">Implementing Liquidity Calculation for Token X</h2>

<p>The functions we&#8217;re going to implement allow us to calculate liquidity ($L = \sqrt{xy}$) when token amounts and price
ranges are known. Luckily, we already know all the formulas. Let&#8217;s recall this one:</p>

\[\Delta x = \Delta \frac{1}{\sqrt{P}}L\]

<p>In a previous chapter, we used this formula to calculate swap amounts ($\Delta x$ in this case) and now we&#8217;re going to
use it to find $L$:</p>

\[L = \frac{\Delta x}{\Delta \frac{1}{\sqrt{P}}}\]

<p>Or, after simplifying it:
\(L = \frac{\Delta x \sqrt{P_u} \sqrt{P_l}}{\sqrt{P_u} - \sqrt{P_l}}\)</p>

<p>Where $\Delta\sqrt{P} = \sqrt{P_u} - \sqrt{P_l}$ and $\Delta\frac{1}{\sqrt{P}} = \frac{1}{\sqrt{P_u}}-\frac{1}{\sqrt{P_l}}$
and $P_u$ is the bigger of the two prices and $P_l$ is the smaller of them.</p>

<p>In Solidity, we&#8217;ll again use <code class="language-plaintext highlighter-rouge">PRBMath</code> to handle overflows when multiplying and then dividing:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getLiquidityForAmount0</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceAX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceBX96</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amount0</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceAX96</span> <span class="o">&gt;</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sqrtPriceAX96</span><span class="p">,</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtPriceBX96</span><span class="p">,</span> <span class="n">sqrtPriceAX96</span><span class="p">);</span>

    <span class="kt">uint256</span> <span class="n">intermediate</span> <span class="o">=</span> <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span>
        <span class="n">sqrtPriceAX96</span><span class="p">,</span>
        <span class="n">sqrtPriceBX96</span><span class="p">,</span>
        <span class="n">FixedPoint96</span><span class="p">.</span><span class="n">Q96</span>
    <span class="p">);</span>
    <span class="n">liquidity</span> <span class="o">=</span> <span class="kt">uint128</span><span class="p">(</span>
        <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span><span class="n">amount0</span><span class="p">,</span> <span class="n">intermediate</span><span class="p">,</span> <span class="n">sqrtPriceBX96</span> <span class="o">-</span> <span class="n">sqrtPriceAX96</span><span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="implementing-liquidity-calculation-for-token-y">Implementing Liquidity Calculation for Token Y</h2>

<p>Likewise, we&#8217;re using a formula from the other chapter to find $L$ when amount of $Y$ and price range is known:
\(\Delta y = \Delta\sqrt{P} L\)
\(L = \frac{\Delta y}{\sqrt{P_u}-\sqrt{P_l}}\)</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getLiquidityForAmount1</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceAX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceBX96</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amount1</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceAX96</span> <span class="o">&gt;</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sqrtPriceAX96</span><span class="p">,</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtPriceBX96</span><span class="p">,</span> <span class="n">sqrtPriceAX96</span><span class="p">);</span>

    <span class="n">liquidity</span> <span class="o">=</span> <span class="kt">uint128</span><span class="p">(</span>
        <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span>
            <span class="n">amount1</span><span class="p">,</span>
            <span class="n">FixedPoint96</span><span class="p">.</span><span class="n">Q96</span><span class="p">,</span>
            <span class="n">sqrtPriceBX96</span> <span class="o">-</span> <span class="n">sqrtPriceAX96</span>
        <span class="p">)</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I hope this is clear!</p>

<h2 id="finding-fair-liquidity">Finding Fair Liquidity</h2>

<p>You might be wondering why there are two ways of calculating $L$ while we have always had only one $L$, which is
calculated as $L = \sqrt{xy}$, and which of these ways is correct. The answer is: they&#8217;re both correct.</p>

<p>In the above formulas, we calculate $L$ based on different parameters: price range and the amount of either token.
Different price ranges and different token amounts will result in different values of $L$. And there&#8217;s a scenario where
we need to calculate both of the $L$&#8217;s and pick one of them. Recall this piece from <code class="language-plaintext highlighter-rouge">mint</code> function:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span> <span class="o">&lt;</span> <span class="n">lowerTick</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">amount0</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount0Delta</span><span class="p">(...);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span> <span class="o">&lt;</span> <span class="n">upperTick</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">amount0</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount0Delta</span><span class="p">(...);</span>

    <span class="n">amount1</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount1Delta</span><span class="p">(...);</span>

    <span class="n">liquidity</span> <span class="o">=</span> <span class="n">LiquidityMath</span><span class="p">.</span><span class="n">addLiquidity</span><span class="p">(</span><span class="n">liquidity</span><span class="p">,</span> <span class="kt">int128</span><span class="p">(</span><span class="n">amount</span><span class="p">));</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">amount1</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">calcAmount1Delta</span><span class="p">(...);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It turns out, we also need to follow this logic when calculating liquidity:</p>
<ol>
  <li>If we&#8217;re calculating liquidity for a range that&#8217;s below current price, we use the $\Delta x$ version on the formula.</li>
  <li>When calculation liquidity for a range that&#8217;s above current price, we use the $\Delta y$ one.</li>
  <li>When a price range includes the current price, we calculate <strong>both</strong> and pick the smaller of them.</li>
</ol>

<p>The reasoning is the same as that of the piece of the code above: when price range is outside of current price, it&#8217;s
entirely configured by either of the tokens, not both of them.</p>

<p>Let&#8217;s implement this logic now.
When current price is below the lower bound of a price range:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getLiquidityForAmounts</span><span class="p">(</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceAX96</span><span class="p">,</span>
    <span class="kt">uint160</span> <span class="n">sqrtPriceBX96</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amount0</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amount1</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint128</span> <span class="n">liquidity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceAX96</span> <span class="o">&gt;</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span>
        <span class="p">(</span><span class="n">sqrtPriceAX96</span><span class="p">,</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrtPriceBX96</span><span class="p">,</span> <span class="n">sqrtPriceAX96</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceX96</span> <span class="o">&lt;=</span> <span class="n">sqrtPriceAX96</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">liquidity</span> <span class="o">=</span> <span class="n">getLiquidityForAmount0</span><span class="p">(</span>
            <span class="n">sqrtPriceAX96</span><span class="p">,</span>
            <span class="n">sqrtPriceBX96</span><span class="p">,</span>
            <span class="n">amount0</span>
        <span class="p">);</span>
</code></pre></div></div>

<p>When current price is within a range:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sqrtPriceX96</span> <span class="o">&lt;=</span> <span class="n">sqrtPriceBX96</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint128</span> <span class="n">liquidity0</span> <span class="o">=</span> <span class="n">getLiquidityForAmount0</span><span class="p">(</span>
        <span class="n">sqrtPriceX96</span><span class="p">,</span>
        <span class="n">sqrtPriceBX96</span><span class="p">,</span>
        <span class="n">amount0</span>
    <span class="p">);</span>
    <span class="kt">uint128</span> <span class="n">liquidity1</span> <span class="o">=</span> <span class="n">getLiquidityForAmount1</span><span class="p">(</span>
        <span class="n">sqrtPriceAX96</span><span class="p">,</span>
        <span class="n">sqrtPriceX96</span><span class="p">,</span>
        <span class="n">amount1</span>
    <span class="p">);</span>

    <span class="n">liquidity</span> <span class="o">=</span> <span class="n">liquidity0</span> <span class="o">&lt;</span> <span class="n">liquidity1</span> <span class="o">?</span> <span class="n">liquidity0</span> <span class="o">:</span> <span class="n">liquidity1</span><span class="p">;</span>
</code></pre></div></div>

<p>We&#8217;re picking the smaller $L$ because the bigger one already includes it.</p>

<p>[TODO: what about different distances between P_l-P-P_u? Will L be much smaller if P-P_l is smaller than P_u-P?]</p>

<p>And finally:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">liquidity</span> <span class="o">=</span> <span class="n">getLiquidityForAmount1</span><span class="p">(</span>
        <span class="n">sqrtPriceAX96</span><span class="p">,</span>
        <span class="n">sqrtPriceBX96</span><span class="p">,</span>
        <span class="n">amount1</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Done.</p>
