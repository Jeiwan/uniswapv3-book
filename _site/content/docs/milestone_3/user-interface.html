
<h1 id="user-interface">User Interface</h1>

<p>We’re now ready to update the UI with the changes we made in this milestone. We’ll update two things:</p>
<ol>
  <li>Add Liquidity dialog window.</li>
  <li>Slippage tolerance in swapping.</li>
</ol>

<h2 id="add-liquidity-dialog">Add Liquidity Dialog</h2>

<p><img src="/images/milestone_3_add_liquidity_dialog.png" alt="Add Liquidity dialog window" /></p>

<p>This change will finally remove hard coded liquidity amounts from our code and will allow use to add liquidity at
arbitrary ranges.</p>

<p>The dialog is a simple component with a couple of inputs. We can even re-use <code class="language-plaintext highlighter-rouge">addLiquidity</code> function from previous
implementation. However, now we need to convert prices to tick indices in JavaScript: we want users to type in prices
but the contracts expect ticks. To make our job easier, we’ll use <a href="https://github.com/Uniswap/v3-sdk/">the official Uniswap V3 SDK</a>
for that.</p>

<p>To convert price to $\sqrt{P}$, we can use <a href="https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/utils/encodeSqrtRatioX96.ts">encodeSqrtRatioX96</a>
function. The function takes two amounts as input and calculates a price by dividing one by the other. Since we expect
prices for users, we can pass a price as the first argument and 1 as the second one:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">priceToSqrtP</span> <span class="o">=</span> <span class="p">(</span><span class="nx">price</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">encodeSqrtRatioX96</span><span class="p">(</span><span class="nx">price</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>To convert price to tick index, we can use <a href="https://github.com/Uniswap/v3-sdk/blob/08a7c050cba00377843497030f502c05982b1c43/src/utils/tickMath.ts#L82">TickMath.getTickAtSqrtRatio</a>
function. This is the implementation of the Solidity TickMath library in JavaScript:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">priceToTick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">price</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">TickMath</span><span class="p">.</span><span class="nx">getTickAtSqrtRatio</span><span class="p">(</span><span class="nx">priceToSqrtP</span><span class="p">(</span><span class="nx">price</span><span class="p">));</span>
</code></pre></div></div>

<p>So we can now convert prices typed in by users to ticks:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">lowerTick</span> <span class="o">=</span> <span class="nx">priceToTick</span><span class="p">(</span><span class="nx">lowerPrice</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">upperTick</span> <span class="o">=</span> <span class="nx">priceToTick</span><span class="p">(</span><span class="nx">upperPrice</span><span class="p">);</span>
</code></pre></div></div>

<p>Another thing we need to add here is slippage protection. For simplicity, I made it a hard coded value and set it to 0.5%.
Here’s how to use slippage tolerance to calculate minimal amounts:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">slippage</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">amount0Desired</span> <span class="o">=</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">parseEther</span><span class="p">(</span><span class="nx">amount0</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">amount1Desired</span> <span class="o">=</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">parseEther</span><span class="p">(</span><span class="nx">amount1</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">amount0Min</span> <span class="o">=</span> <span class="nx">amount0Desired</span><span class="p">.</span><span class="nx">mul</span><span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="nx">slippage</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">).</span><span class="nx">div</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">amount1Min</span> <span class="o">=</span> <span class="nx">amount1Desired</span><span class="p">.</span><span class="nx">mul</span><span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="nx">slippage</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">).</span><span class="nx">div</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="slippage-tolerance-in-swapping">Slippage Tolerance in Swapping</h2>

<p>Even though we’re the only user of the application and thus will never have problems with slippage during development,
let’s add an input to control slippage tolerance during swaps.</p>

<p><img src="/images/milestone_3_slippage_tolerance.png" alt="Main screen of the web app" /></p>

<p>When swapping, slippage protection is implemented via limiting price–a price we don’t to go above during a swap. This
means that we need to know this price before sending a swap transaction. However, we don’t need to calculate it on the
front end because Quoter contract does this for us:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">quote</span><span class="p">(</span><span class="n">QuoteParams</span> <span class="k">memory</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">public</span>
    <span class="k">returns</span> <span class="p">(</span>
        <span class="kt">uint256</span> <span class="n">amountOut</span><span class="p">,</span>
        <span class="kt">uint160</span> <span class="n">sqrtPriceX96After</span><span class="p">,</span>
        <span class="kt">int24</span> <span class="n">tickAfter</span>
    <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>And we’re calling Quoter to calculate swap amounts.</p>

<p>So, to calculate limiting price we need to take <code class="language-plaintext highlighter-rouge">sqrtPriceX96After</code> and subtract slippage tolerance from it–this will be
the price we don’t want to go below during a swap.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">const</span> <span class="n">limitPrice</span> <span class="o">=</span> <span class="n">priceAfter</span><span class="p">.</span><span class="n">mul</span><span class="p">((</span><span class="mi">100</span> <span class="o">-</span> <span class="n">parseFloat</span><span class="p">(</span><span class="n">slippage</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">).</span><span class="n">div</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
</code></pre></div></div>

<p>And that’s it!</p>
