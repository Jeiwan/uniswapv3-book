<h2 id="flash-loans">Flash Loans</h2>

<p>Both Uniswap V2 and V3 implement flash loans: an unlimited and uncollateralized loan that must be repaid in the same
transaction. Pools are basically giving caller an arbitrary amount of tokens that caller requests, but, by the end of
the call, caller must return the full amount plus fee.</p>

<p>The fact that flash loans must be repaid in the same transaction means that flash loans cannot be taken by regular users:
as a user, you cannot program custom logic in transactions. Flash loans can only be taken and repaid by smart contracts.</p>

<p>Flash loans is a powerful financial instrument in DeFi. While it’s often used to exploit vulnerabilities in DeFi
protocols (by inflating pool balances and abusing flawed state management), it’s has many good applications (e.g.
leveraged positions management on lending protocols)–this is why DeFi applications that store liquidity provide
permissionless flash loans.</p>

<h3 id="implementing-flash-loans">Implementing Flash Loans</h3>

<p>In Uniswap V2 flash loans were part of the swapping functionality: it was possible to borrow tokens during a swap, but
you had to return them, or an equal amount of the other pool tokens, in the same transaction. In V3, flash loans are
separated from swapping–it’s simply a function that gives caller an amount of tokens they requested, calls a callback
on the caller, and ensures a flash loan was repaid:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">flash</span><span class="p">(</span>
    <span class="kt">uint256</span> <span class="n">amount0</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">amount1</span><span class="p">,</span>
    <span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span>
<span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="n">balance0Before</span> <span class="o">=</span> <span class="n">IERC20</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">));</span>
    <span class="kt">uint256</span> <span class="n">balance1Before</span> <span class="o">=</span> <span class="n">IERC20</span><span class="p">(</span><span class="n">token1</span><span class="p">).</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">IERC20</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">IERC20</span><span class="p">(</span><span class="n">token1</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>

    <span class="n">IUniswapV3FlashCallback</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">).</span><span class="n">uniswapV3FlashCallback</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="nb">require</span><span class="p">(</span><span class="n">IERC20</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">balance0Before</span><span class="p">);</span>
    <span class="nb">require</span><span class="p">(</span><span class="n">IERC20</span><span class="p">(</span><span class="n">token1</span><span class="p">).</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">balance1Before</span><span class="p">);</span>

    <span class="k">emit</span> <span class="n">Flash</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount0</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function sends tokens to the caller and then calls <code class="language-plaintext highlighter-rouge">uniswapV3FlashCallback</code> on it–this is where the caller is expected
to repay the loan. Then the function ensures that it’s balances haven’t decreased. Notice that custom data is allowed
to be passed to the callback.</p>

<p>Here’s an example of the callback implementation:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">uniswapV3FlashCallback</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">calldata</span> <span class="n">data</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">uint256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount1</span><span class="p">)</span> <span class="o">=</span> <span class="n">abi</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="p">(</span><span class="kt">uint256</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">token0</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">token1</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this implementation, we’re simply sending tokens back to the pool (I used this callback in <code class="language-plaintext highlighter-rouge">flash</code> function tests).
In reality, it can use the loaned amounts to perform some operations on other DeFi protocols. But it always must repay
the loan in this callback.</p>

<p>And that’s it!</p>
