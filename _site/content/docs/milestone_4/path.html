<h1 id="swap-path">Swap Path</h1>

<p>Let’s imagine that we have only these pools: WETH/USDC, USDC/USDT, WBTC/USDT. If we want to swap WETH for WBTC, we’ll
need to make multiple swaps (WETH→USDC→USDT→WBTC) since there’s no WETH/WBTC pool. We can do this manually or we can
improve our contracts to handle such chained, or multi-pool, swaps. Of course, we’ll do the latter!</p>

<p>When doing multi-pool swaps, we’re sending output of a previous swap to the input of the next one. For example:</p>

<ol>
  <li>In WETH/USDC pool, we’re selling WETH and buying USDC.</li>
  <li>In USDC/USDT pool, we’re selling USDC from the previous swap and buying USDT.</li>
  <li>In WBTC/USDT pool, we’re selling USDT from the previous pool and buying WBTC.</li>
</ol>

<p>We can turn this series into a path:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WETH/USDC,USDC/USDT,WBTC/USDT
</code></pre></div></div>

<p>And iterate over such path in our contracts to perform multiple swaps in one transaction. However, recall from the previous
chapter that we don’t need to know pool addresses and, instead, we can derive them from pool parameters. Thus, the above
swap can be turned into:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WETH, USDC, USDT, WBTC
</code></pre></div></div>

<p>And recall that tick spacing is another parameter (besides tokens) that identifies a pool. Thus, the above path becomes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WETH, 60, USDC, 10, USDT, 60, WBTC
</code></pre></div></div>

<p>Where 60 and 10 are tick spacings. We’re using 60 for volatile assets like ETH and BTC, and 10 for stablecoins.</p>

<p>Now, having such path, we can iterate over it to build pool parameters for each of the pool:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">WETH, 60, USDC</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">USDC, 10, USDT</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">USDT, 60, WBTC</code>.</li>
</ol>

<p>Knowing these parameters, we can derive pool addresses using <code class="language-plaintext highlighter-rouge">PoolAddress.computeAddress</code>, which we implemented in the
previous chapter.</p>

<p>Let’s build a library to work with swap paths.</p>

<h2 id="path-library">Path Library</h2>

<p>In code, path is a sequence of bytes. In Solidity, a path can be built like that:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bytes</span><span class="p">.</span><span class="n">concat</span><span class="p">(</span>
    <span class="kt">bytes20</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">weth</span><span class="p">)),</span>
    <span class="kt">bytes3</span><span class="p">(</span><span class="kt">uint24</span><span class="p">(</span><span class="mi">60</span><span class="p">)),</span>
    <span class="kt">bytes20</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">usdc</span><span class="p">)),</span>
    <span class="kt">bytes3</span><span class="p">(</span><span class="kt">uint24</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>
    <span class="kt">bytes20</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">usdt</span><span class="p">)),</span>
    <span class="kt">bytes3</span><span class="p">(</span><span class="kt">uint24</span><span class="p">(</span><span class="mi">60</span><span class="p">)),</span>
    <span class="kt">bytes20</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">wbtc</span><span class="p">))</span>
<span class="p">);</span>
</code></pre></div></div>

<p>And it looks like that:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 <span class="c"># weth address</span>
  00003c                                   <span class="c"># 60</span>
  A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 <span class="c"># usdc address</span>
  00000a                                   <span class="c"># 10</span>
  dAC17F958D2ee523a2206206994597C13D831ec7 <span class="c"># usdt address</span>
  00003c                                   <span class="c"># 60</span>
  2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599 <span class="c"># wbtc address</span>
</code></pre></div></div>

<p>Here’s a set of function that we’ll need to implement:</p>
<ol>
  <li>calculating the number of pools in a path;</li>
  <li>figuring out if a path has multiple tokens;</li>
  <li>extracting first pool parameters from a path;</li>
  <li>proceeding to a next pair in a path;</li>
  <li>and decoding first pool parameters;</li>
</ol>

<h3 id="calculating-the-number-of-pools-in-a-path">Calculating the Number of Pools in a Path</h3>
<p>Let’s begin with calculating the number of pools in a path:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Path.sol
</span><span class="k">library</span> <span class="n">Path</span> <span class="p">{</span>
    <span class="c1">/// @dev The length the bytes encoded address
</span>    <span class="kt">uint256</span> <span class="k">private</span> <span class="k">constant</span> <span class="n">ADDR_SIZE</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="c1">/// @dev The length the bytes encoded tick spacing
</span>    <span class="kt">uint256</span> <span class="k">private</span> <span class="k">constant</span> <span class="n">TICKSPACING_SIZE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">/// @dev The offset of a single token address + tick spacing
</span>    <span class="kt">uint256</span> <span class="k">private</span> <span class="k">constant</span> <span class="n">NEXT_OFFSET</span> <span class="o">=</span> <span class="n">ADDR_SIZE</span> <span class="o">+</span> <span class="n">TICKSPACING_SIZE</span><span class="p">;</span>
    <span class="c1">/// @dev The offset of an encoded pool key (tokenIn + tick spacing + tokenOut)
</span>    <span class="kt">uint256</span> <span class="k">private</span> <span class="k">constant</span> <span class="n">POP_OFFSET</span> <span class="o">=</span> <span class="n">NEXT_OFFSET</span> <span class="o">+</span> <span class="n">ADDR_SIZE</span><span class="p">;</span>
    <span class="c1">/// @dev The minimum length of a path that contains 2 or more pools;
</span>    <span class="kt">uint256</span> <span class="k">private</span> <span class="k">constant</span> <span class="n">MULTIPLE_POOLS_MIN_LENGTH</span> <span class="o">=</span>
        <span class="n">POP_OFFSET</span> <span class="o">+</span> <span class="n">NEXT_OFFSET</span><span class="p">;</span>

    <span class="p">...</span>
</code></pre></div></div>

<p>We first define a few constants:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">ADDR_SIZE</code> is the size of an address, 20 bytes;</li>
  <li><code class="language-plaintext highlighter-rouge">TICKSPACING_SIZE</code> is the size of a tick spacing, 3 bytes (<code class="language-plaintext highlighter-rouge">uint24</code>);</li>
  <li><code class="language-plaintext highlighter-rouge">NEXT_OFFSET</code> is the offset of a next token address–to get it, we skip an address and a tick spacing;</li>
  <li><code class="language-plaintext highlighter-rouge">POP_OFFSET</code> is the offset of a pool key (token address + tick spacing + token address);</li>
  <li><code class="language-plaintext highlighter-rouge">MULTIPLE_POOLS_MIN_LENGTH</code> is the length of a path that contains 2 or more pools (one set of pool parameters + tick
spacing + token address).</li>
</ol>

<p>To count the number of pools in a path, we subtract the size of an address (first or last token in a path) and divide
the remaining part by <code class="language-plaintext highlighter-rouge">NEXT_OFFSET</code> (address + tick spacing):</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">numPools</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">path</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">ADDR_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="n">NEXT_OFFSET</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="figuring-out-if-a-path-has-multiple-tokens">Figuring Out If a Path Has Multiple Tokens</h3>
<p>To check if there are multiple pools in a path, we need to compare the length of a path with <code class="language-plaintext highlighter-rouge">MULTIPLE_POOLS_MIN_LENGTH</code>:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">hasMultiplePools</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">path</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">path</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">MULTIPLE_POOLS_MIN_LENGTH</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="extracting-first-pool-parameters-from-a-path">Extracting First Pool Parameters From a Path</h3>

<p>To implement the other functions, we’ll need a helper library because Solidity doesn’t have native bytes manipulation
functions. Specifically, we’ll need a function to extract a sub-array from an array of bytes, and a couple of functions
to convert bytes to address and <code class="language-plaintext highlighter-rouge">uint24</code>.</p>

<p>Luckily, there’s a great open-source library called <a href="https://github.com/GNSPS/solidity-bytes-utils">solidity-bytes-utils</a>.
To use the library, we need to extend <code class="language-plaintext highlighter-rouge">bytes</code> type in <code class="language-plaintext highlighter-rouge">Path</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">library</span> <span class="n">Path</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">BytesLib</span> <span class="k">for</span> <span class="kt">bytes</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can implement <code class="language-plaintext highlighter-rouge">getFirstPool</code> now:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getFirstPool</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">pure</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">path</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">POP_OFFSET</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function simply returns “token address + tick spacing + token address” encoded as bytes.</p>

<h3 id="proceeding-to-a-next-pair-in-a-path">Proceeding to a Next Pair in a Path</h3>

<p>We’ll use the next function when iterating over a path and throwing away processed pools. Notice that we’re removing
“token address + tick spacing”, not full pool parameters, because we need the other token address to calculate next pool
address.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">skipToken</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">path</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">path</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">NEXT_OFFSET</span><span class="p">,</span> <span class="n">path</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">NEXT_OFFSET</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="decoding-first-pool-parameters">Decoding First Pool Parameters</h3>

<p>And, finally, we need to decode first pool parameters in a pool:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">decodeFirstPool</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">path</span><span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">pure</span>
    <span class="k">returns</span> <span class="p">(</span>
        <span class="kt">address</span> <span class="n">tokenIn</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">tokenOut</span><span class="p">,</span>
        <span class="kt">uint24</span> <span class="n">tickSpacing</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="n">tokenIn</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">toAddress</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">tickSpacing</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">toUint24</span><span class="p">(</span><span class="n">ADDR_SIZE</span><span class="p">);</span>
    <span class="n">tokenOut</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">toAddress</span><span class="p">(</span><span class="n">NEXT_OFFSET</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Unfortunately, <code class="language-plaintext highlighter-rouge">BytesLib</code> doesn’t implement <code class="language-plaintext highlighter-rouge">toUint24</code> function but we can implement it ourselves! Find a similar function
in <code class="language-plaintext highlighter-rouge">BytesLib.sol</code> and turn it into a <code class="language-plaintext highlighter-rouge">uint24</code> one:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">library</span> <span class="n">BytesLibExt</span> <span class="p">{</span>
    <span class="k">function</span> <span class="n">toUint24</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span> <span class="n">_bytes</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">_start</span><span class="p">)</span>
        <span class="k">internal</span>
        <span class="k">pure</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint24</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">_bytes</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">_start</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"toUint24_outOfBounds"</span><span class="p">);</span>
        <span class="kt">uint24</span> <span class="n">tempUint</span><span class="p">;</span>

        <span class="k">assembly</span> <span class="p">{</span>
            <span class="n">tempUint</span> <span class="o">:=</span> <span class="n">mload</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">_bytes</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">),</span> <span class="n">_start</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">tempUint</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re doing this in a new library contract, which we can then use in our Path library alongside <code class="language-plaintext highlighter-rouge">BytesLib</code>:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">library</span> <span class="n">Path</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">BytesLib</span> <span class="k">for</span> <span class="kt">bytes</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">BytesLibExt</span> <span class="k">for</span> <span class="kt">bytes</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>
