<h1 id="user-interface">User Interface</h1>

<p>After introducing swap paths, we can significantly simplify the internal of our web app. First of all, every swap now
uses a path since path doesn’t have to contain multiple pools. Second, it’s now easier to change the direction of swap:
we can simply reverse the path. And, thanks to the unified pool address generation via <code class="language-plaintext highlighter-rouge">CREATE2</code> and unique salts, we
no longer need to store pool addresses and care about tokens order.</p>

<p>However, we cannot integrate multi-pool swaps in the web app without adding one crucial algorithm. Ask yourself the
question: “How to find a path between two tokens that don’t have a pool?”</p>

<h2 id="autorouter">AutoRouter</h2>

<p>Uniswap implements what’s called <em>AutoRouter</em>, an algorithm that find shortest path between two tokens. Moreover, it also
splits one payment into multiple smaller payments to find the best average exchange rate. The profit can be as big as 
<a href="https://uniswap.org/blog/auto-router-v2">36.84% compared to trades that are not split</a>. This sounds great, however, we’re
not going to build such an advanced algorithm. Instead, we’ll be a simpler one.</p>

<h2 id="a-simple-router-design">A Simple Router Design</h2>

<p>Suppose we have a whole bunch of pools:</p>

<p>[TODO: illustrate]</p>

<p>How do find a shortest path between two tokens in such a mess?</p>

<p>The most suitable solution for such kind of task is based on a <em>graph</em>. A graph is a data structure that consists of
nodes (objects representing something) and edges (links connecting nodes). We can turn that mess of pools into a graph
where each node is a token (that has a pool) and each edge is a pool this token belongs to. So a pool represented as a
graph is two nodes connected with an edge. And the above pools become this graph:</p>

<p>[TODO: illustrate]</p>

<p>The biggest advantage graphs give us is the ability to traverse them, from one node to another, to find paths. Specifically,
we’ll use <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* search algorithm</a>. Feel free learning about how the
algorithm works, but, in our app, we’ll use a library to make our life easier. The set of libraries we’ll use is:
<a href="https://github.com/anvaka/ngraph.graph">ngraph.ngraph</a> for building graphs and <a href="https://github.com/anvaka/ngraph.path">ngraph.path</a>
for finding paths (it’s the latter that implements A* search algorithm, as well as some others).</p>

<p>In the UI app, let’s create a path finder. This will be a class that, when instantiated, turns a list of pairs into a
graph to later use the graph to find a shortest path between two tokens.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">createGraph</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">ngraph.graph</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">path</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">ngraph.path</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">PathFinder</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">pairs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">graph</span> <span class="o">=</span> <span class="nx">createGraph</span><span class="p">();</span>

    <span class="nx">pairs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">pair</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">pair</span><span class="p">.</span><span class="nx">token0</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">pair</span><span class="p">.</span><span class="nx">token1</span><span class="p">.</span><span class="nx">address</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">.</span><span class="nx">addLink</span><span class="p">(</span><span class="nx">pair</span><span class="p">.</span><span class="nx">token0</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">pair</span><span class="p">.</span><span class="nx">token1</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">pair</span><span class="p">.</span><span class="nx">tickSpacing</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">.</span><span class="nx">addLink</span><span class="p">(</span><span class="nx">pair</span><span class="p">.</span><span class="nx">token1</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">pair</span><span class="p">.</span><span class="nx">token0</span><span class="p">.</span><span class="nx">address</span><span class="p">,</span> <span class="nx">pair</span><span class="p">.</span><span class="nx">tickSpacing</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">finder</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">aStar</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">...</span>
</code></pre></div></div>

<p>In the constructor, we’re creating an empty graph and fill it with linked nodes. Each node is a token address and links
have associated data, which is tick spacings–we’ll be able to extract this information from paths found by A<em>. After
initializing a graph, we instantiate A</em> algorithm implementation.</p>

<p>Next, we need to implement a function that will find a path between tokens and turn it into an array of token addresses
and tick spacings:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">findPath</span><span class="p">(</span><span class="nx">fromToken</span><span class="p">,</span> <span class="nx">toToken</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">finder</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">fromToken</span><span class="p">,</span> <span class="nx">toToken</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">orig</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">acc</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">acc</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">graph</span><span class="p">.</span><span class="nx">getLink</span><span class="p">(</span><span class="nx">orig</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="nx">id</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">id</span><span class="p">).</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">acc</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">acc</span><span class="p">;</span>
  <span class="p">},</span> <span class="p">[]).</span><span class="nx">reverse</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">this.finder.find(fromToken, toToken)</code> returns a list of nodes and, unfortunately, doesn’t contain the information
about edges between them (we store tick spacings in edges). Thus, we’re calling <code class="language-plaintext highlighter-rouge">this.graph.getLink(previousNode, currentNode)</code>
to find edges.</p>

<p>Now, whenever user changes input or output token, we can call <code class="language-plaintext highlighter-rouge">pathFinder.findPath(token0, token1)</code> to build a new path.</p>
