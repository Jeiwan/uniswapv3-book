<h1 id="factory-contract">Factory Contract</h1>

<p>Uniswap is designed in a way that assumes many discrete Pool contracts, with each pool handling swaps of one token pair.
This looks problematic when we want to swap between two tokens that don’t have a pool–is there’s no pool, no swaps are
possible. However, we can still do intermediate swaps: first swap to a token that has pairs with either of the tokens
and then swap this token to the target token. This can also go deeper and have more intermediate tokens. However,
doing this manually is cumbersome, and, luckily, we can the process easier by implementing it in our smart contracts.</p>

<p><strong>Factory contract</strong> is a contract that serves multiple purposes:</p>
<ol>
  <li>It acts as a centralized registry of Pool contracts. Using a factory, you can find all deployed pools, their tokens,
and addresses.</li>
  <li>It simplifies deployment of Pool contracts. EVM allows to deploy smart contracts from smart contracts–Factory uses
this feature to make pools deployment a breeze.</li>
  <li>It makes pool addresses predictable and allows to calculate them without making calls to the registry. This makes
pools easily discoverable.</li>
</ol>

<p>Let’s build Factory contract! But before this, we need to learn a new mechanism.</p>

<h2 id="create-and-create2-opcodes"><code class="language-plaintext highlighter-rouge">CREATE</code> and <code class="language-plaintext highlighter-rouge">CREATE2</code> Opcodes</h2>

<p>EVM has two ways of deploying contracts: via <code class="language-plaintext highlighter-rouge">CREATE</code> or via <code class="language-plaintext highlighter-rouge">CREATE2</code> opcode. The only difference between them is how
new contract address is generated:
1 <code class="language-plaintext highlighter-rouge">CREATE</code> uses deployer’s account <code class="language-plaintext highlighter-rouge">nonce</code> to generate a contract address (in pseudocode):
    <code class="language-plaintext highlighter-rouge">
    KECCAK256(deployer.address, deployer.nonce)
   </code>
  <code class="language-plaintext highlighter-rouge">nonce</code> is an account-specific counter of transactions. Using <code class="language-plaintext highlighter-rouge">nonce</code> in new contract address generation makes it hard
to compute an address in other contracts or off-chain apps, mainly because, to find the nonce a contract was deployed at,
one needs to scan historical account transactions.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">CREATE2</code> uses a custom <em>salt</em> to generate a contract address. This is just an arbitrary sequence of bytes chosen
by a developer, which is used to make address generation deterministic (and reduces the chance of a collision).</li>
</ol>

<p>We need to know the difference because Factory uses <code class="language-plaintext highlighter-rouge">CREATE2</code> when deploying Pool contracts so pools get unique <strong>and</strong>
deterministic addresses that can be computed in other contracts and off-chain apps. Specifically, for salt, Factory
computes a hash using these pool parameters:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="n">token0</span><span class="p">,</span> <span class="n">token1</span><span class="p">,</span> <span class="n">tickSpacing</span><span class="p">))</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">token0</code> and <code class="language-plaintext highlighter-rouge">token</code> are the addresses of pool tokens, and <code class="language-plaintext highlighter-rouge">tickSpacing</code> is something we haven’t learned yet. Let’s fix
that!</p>

<h2 id="tick-spacing">Tick Spacing</h2>

<p>Recall the loop in <code class="language-plaintext highlighter-rouge">swap</code> function:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span>
    <span class="n">state</span><span class="p">.</span><span class="n">amountSpecifiedRemaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span> <span class="o">!=</span> <span class="n">sqrtPriceLimitX96</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">(</span><span class="n">step</span><span class="p">.</span><span class="n">nextTick</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">tickBitmap</span><span class="p">.</span><span class="n">nextInitializedTickWithinOneWord</span><span class="p">(...);</span>
    <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">step</span><span class="p">.</span><span class="n">amountIn</span><span class="p">,</span> <span class="n">step</span><span class="p">.</span><span class="n">amountOut</span><span class="p">)</span> <span class="o">=</span> <span class="n">SwapMath</span><span class="p">.</span><span class="n">computeSwapStep</span><span class="p">(...);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This loop finds initialized ticks that have some liquidity by iterating them in either of the directions. This iterating,
however, is not an expensive operation: if a tick is away, the code would need to pass all the tick the current and the
target one, which consumes gas. To make this loop more gas-efficient, Uniswap pools have <code class="language-plaintext highlighter-rouge">tickSpacing</code> setting which acts
as a scaling factor: <code class="language-plaintext highlighter-rouge">1</code> means every tick is counted, <code class="language-plaintext highlighter-rouge">10</code> means only every 10th tick is counted, <code class="language-plaintext highlighter-rouge">60</code> means only every
60th tick is counter, and so on.</p>

<p>[TODO: illustrate]</p>

<p>However, the higher the tick spacing the lower the precision. Low volatility pairs (e.g. stablecoin pairs) need higher
precision because price movements are narrow in such pairs. Medium and high volatility pairs need lower precision since
price movement are wide in such pairs. To handle this diversity, Uniswap allows to pick a tick spacing when a pair is
deployed. Uniswap allows deployers to choose from these options: 10, 60, or 200. And we’ll have only 10 and 60 for
simplicity.</p>

<p>Thus, each pool is uniquely identified by this set of parameters:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">token0</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">token1</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">tickSpacing</code>;</li>
</ol>

<blockquote>
  <p>And, yes, there can pools with the same tokens but different tick spacing.</p>
</blockquote>

<p>Factory contract uses this set of parameters as a unique identifier of a pool and passes it as a salt to generate a new
pool contract address.</p>

<blockquote>
  <p>From now on, we’ll assume 60 tick spacing for all our pools.</p>
</blockquote>

<h2 id="factory-implementation">Factory Implementation</h2>

<p>In the constructor of Factory, we need to initialize supported tick spacings:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Factory.sol
</span><span class="k">contract</span> <span class="n">UniswapV3Factory</span> <span class="k">is</span> <span class="n">IUniswapV3PoolDeployer</span> <span class="p">{</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">uint24</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="k">public</span> <span class="n">tickSpacings</span><span class="p">;</span>
    <span class="k">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">tickSpacings</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">tickSpacings</span><span class="p">[</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>
</code></pre></div></div>

<blockquote>
  <p>We could’ve made them constants, but we’ll need to have it as a mapping for a later milestone.</p>
</blockquote>

<p>Factory contract is a contract with only one function <code class="language-plaintext highlighter-rouge">createPool</code>. The function begins with necessary checks we need to
make before creating a pool:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Factory.sol
</span><span class="k">contract</span> <span class="n">UniswapV3Factory</span> <span class="k">is</span> <span class="n">IUniswapV3PoolDeployer</span> <span class="p">{</span>
    <span class="n">PoolParameters</span> <span class="k">public</span> <span class="n">parameters</span><span class="p">;</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">uint24</span> <span class="o">=&gt;</span> <span class="kt">address</span><span class="p">)))</span>
        <span class="k">public</span> <span class="n">pools</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="k">function</span> <span class="n">createPool</span><span class="p">(</span>
        <span class="kt">address</span> <span class="n">tokenX</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">tokenY</span><span class="p">,</span>
        <span class="kt">uint24</span> <span class="n">tickSpacing</span>
    <span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tokenX</span> <span class="o">==</span> <span class="n">tokenY</span><span class="p">)</span> <span class="nb">revert</span> <span class="n">TokensMustBeDifferent</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tickSpacings</span><span class="p">[</span><span class="n">tickSpacing</span><span class="p">])</span> <span class="nb">revert</span> <span class="n">UnsupportedTickSpacing</span><span class="p">();</span>

        <span class="p">(</span><span class="n">tokenX</span><span class="p">,</span> <span class="n">tokenY</span><span class="p">)</span> <span class="o">=</span> <span class="n">tokenX</span> <span class="o">&lt;</span> <span class="n">tokenY</span>
            <span class="o">?</span> <span class="p">(</span><span class="n">tokenX</span><span class="p">,</span> <span class="n">tokenY</span><span class="p">)</span>
            <span class="o">:</span> <span class="p">(</span><span class="n">tokenY</span><span class="p">,</span> <span class="n">tokenX</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tokenX</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="nb">revert</span> <span class="n">TokenXCannotBeZero</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pools</span><span class="p">[</span><span class="n">tokenX</span><span class="p">][</span><span class="n">tokenY</span><span class="p">][</span><span class="n">tickSpacing</span><span class="p">]</span> <span class="o">!=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="nb">revert</span> <span class="n">PoolAlreadyExists</span><span class="p">();</span>
        
        <span class="p">...</span>
</code></pre></div></div>

<p>Notice that this is first time when we’re sorting tokens:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">tokenX</span><span class="p">,</span> <span class="n">tokenY</span><span class="p">)</span> <span class="o">=</span> <span class="n">tokenX</span> <span class="o">&lt;</span> <span class="n">tokenY</span>
    <span class="o">?</span> <span class="p">(</span><span class="n">tokenX</span><span class="p">,</span> <span class="n">tokenY</span><span class="p">)</span>
    <span class="o">:</span> <span class="p">(</span><span class="n">tokenY</span><span class="p">,</span> <span class="n">tokenX</span><span class="p">);</span>
</code></pre></div></div>
<p>From now on, we’ll also expect pool token addresses to be sorted, i.e. <code class="language-plaintext highlighter-rouge">token0</code> goes before <code class="language-plaintext highlighter-rouge">token1</code> when sorted. We need
this for consistency, to make salt consistent.</p>

<blockquote>
  <p>This change also affects how we deploy tokens in tests and the deployment script: we need to ensure that WETH is always
<code class="language-plaintext highlighter-rouge">token0</code> to make price calculations simpler in Solidity (otherwise, we’d need to use fractional prices, like 1/5000). If
WETH is not <code class="language-plaintext highlighter-rouge">token0</code> in your tests, change the order of token deployments.</p>
</blockquote>

<p>After that, we prepare pool parameters and deploy a pool:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parameters</span> <span class="o">=</span> <span class="n">PoolParameters</span><span class="p">({</span>
    <span class="n">factory</span><span class="o">:</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span>
    <span class="n">token0</span><span class="o">:</span> <span class="n">tokenX</span><span class="p">,</span>
    <span class="n">token1</span><span class="o">:</span> <span class="n">tokenY</span><span class="p">,</span>
    <span class="n">tickSpacing</span><span class="o">:</span> <span class="n">tickSpacing</span>
<span class="p">});</span>

<span class="n">pool</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span>
    <span class="k">new</span> <span class="n">UniswapV3Pool</span><span class="p">{</span>
        <span class="n">salt</span><span class="o">:</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="n">tokenX</span><span class="p">,</span> <span class="n">tokenY</span><span class="p">,</span> <span class="n">tickSpacing</span><span class="p">))</span>
    <span class="p">}()</span>
<span class="p">);</span>

<span class="k">delete</span> <span class="n">parameters</span><span class="p">;</span>
</code></pre></div></div>

<p>This piece looks weird because <code class="language-plaintext highlighter-rouge">parameters</code> is not used. Uniswap uses <em>Inversion of Control</em> to pass parameters to a
pool during deployment. Let’s look at updated Pool contract constructor:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Pool.sol
</span><span class="k">contract</span> <span class="n">UniswapV3Pool</span> <span class="k">is</span> <span class="n">IUniswapV3Pool</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">factory</span><span class="p">,</span> <span class="n">token0</span><span class="p">,</span> <span class="n">token1</span><span class="p">,</span> <span class="n">tickSpacing</span><span class="p">)</span> <span class="o">=</span> <span class="n">IUniswapV3PoolDeployer</span><span class="p">(</span>
            <span class="n">msg</span><span class="p">.</span><span class="n">sender</span>
        <span class="p">).</span><span class="n">parameters</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="p">..</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Aha! Pool expects its deployer to implement <code class="language-plaintext highlighter-rouge">IUniswapV3PoolDeployer</code> interface (which only defines <code class="language-plaintext highlighter-rouge">parameters</code> getter)
and calls it in the constructor during deployment to get the parameters. This is what the flow looks like:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">Factory</code>: defines <code class="language-plaintext highlighter-rouge">parameters</code> state variable (implements <code class="language-plaintext highlighter-rouge">IUniswapV3PoolDeployer</code>) and sets them before
deploying a pool.</li>
  <li><code class="language-plaintext highlighter-rouge">Factory</code>: deploys a pool.</li>
  <li><code class="language-plaintext highlighter-rouge">Pool</code>: in the constructor, calls <code class="language-plaintext highlighter-rouge">parameters()</code> function on its deployer and expects that pool parameters are
returned.</li>
  <li><code class="language-plaintext highlighter-rouge">Factory</code>: calls <code class="language-plaintext highlighter-rouge">delete parameters;</code> to clean up the slot of <code class="language-plaintext highlighter-rouge">parameters</code> state variable and cut gas consumption.
This is a temporary state variable that has a value only during a call to <code class="language-plaintext highlighter-rouge">createPool()</code>.</li>
</ol>

<p>After a pool is created, we keep in <code class="language-plaintext highlighter-rouge">pools</code> mapping (so it can be found by its tokens) and emit an event:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">pools</span><span class="p">[</span><span class="n">tokenX</span><span class="p">][</span><span class="n">tokenY</span><span class="p">][</span><span class="n">tickSpacing</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>
    <span class="n">pools</span><span class="p">[</span><span class="n">tokenY</span><span class="p">][</span><span class="n">tokenX</span><span class="p">][</span><span class="n">tickSpacing</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">;</span>

    <span class="k">emit</span> <span class="n">PoolCreated</span><span class="p">(</span><span class="n">tokenX</span><span class="p">,</span> <span class="n">tokenY</span><span class="p">,</span> <span class="n">tickSpacing</span><span class="p">,</span> <span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="pool-initialization">Pool Initialization</h2>

<p>As you have noticed from the code above, we no longer set <code class="language-plaintext highlighter-rouge">sqrtPriceX96</code> and <code class="language-plaintext highlighter-rouge">tick</code> in Pool’s constructor–this is now
done in a separate function, <code class="language-plaintext highlighter-rouge">initialize</code>, that needs to be called after pool is deployed:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Pool.sol
</span><span class="k">function</span> <span class="n">initialize</span><span class="p">(</span><span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">slot0</span><span class="p">.</span><span class="n">sqrtPriceX96</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="nb">revert</span> <span class="n">AlreadyInitialized</span><span class="p">();</span>

    <span class="kt">int24</span> <span class="n">tick</span> <span class="o">=</span> <span class="n">TickMath</span><span class="p">.</span><span class="n">getTickAtSqrtRatio</span><span class="p">(</span><span class="n">sqrtPriceX96</span><span class="p">);</span>

    <span class="n">slot0</span> <span class="o">=</span> <span class="n">Slot0</span><span class="p">({</span><span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">tick</span><span class="o">:</span> <span class="n">tick</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So this is how we deploy pools now:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UniswapV3Factory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UniswapV3Factory</span><span class="p">();</span>
<span class="n">UniswapV3Pool</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">UniswapV3Pool</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createPool</span><span class="p">(</span><span class="n">token0</span><span class="p">,</span> <span class="n">token1</span><span class="p">,</span> <span class="n">tickSpacing</span><span class="p">));</span>
<span class="n">pool</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">sqrtP</span><span class="p">(</span><span class="n">currentPrice</span><span class="p">));</span>
</code></pre></div></div>

<h2 id="pooladdress-library"><code class="language-plaintext highlighter-rouge">PoolAddress</code> Library</h2>

<p>Let’s now implement a library that will help us calculate pool contract addresses from other contracts. This library
will have only one function, <code class="language-plaintext highlighter-rouge">computeAddress</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/PoolAddress.sol
</span><span class="k">library</span> <span class="n">PoolAddress</span> <span class="p">{</span>
    <span class="k">function</span> <span class="n">computeAddress</span><span class="p">(</span>
        <span class="kt">address</span> <span class="n">factory</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">token0</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">token1</span><span class="p">,</span>
        <span class="kt">uint24</span> <span class="n">tickSpacing</span>
    <span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">token0</span> <span class="o">&lt;</span> <span class="n">token1</span><span class="p">);</span>
        <span class="p">...</span>
</code></pre></div></div>

<p>The function needs to know pool parameters (this they’re used to build a salt) and Factory contract address. It expects
the tokens to be sorted, which we discussed above.</p>

<p>Now, the core of the function:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pool</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span>
    <span class="kt">uint160</span><span class="p">(</span>
        <span class="kt">uint256</span><span class="p">(</span>
            <span class="nb">keccak256</span><span class="p">(</span>
                <span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span>
                    <span class="s">hex"ff"</span><span class="p">,</span>
                    <span class="n">factory</span><span class="p">,</span>
                    <span class="nb">keccak256</span><span class="p">(</span>
                        <span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="n">token0</span><span class="p">,</span> <span class="n">token1</span><span class="p">,</span> <span class="n">tickSpacing</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="nb">keccak256</span><span class="p">(</span><span class="k">type</span><span class="p">(</span><span class="n">UniswapV3Pool</span><span class="p">).</span><span class="n">creationCode</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>

<p>This is what <code class="language-plaintext highlighter-rouge">CREATE2</code> does under the hood to calculate new token address. Let’s unwind it:</p>

<ol>
  <li>First, we calculate salt (<code class="language-plaintext highlighter-rouge">abi.encodePacked(token0, token1, tickSpacing)</code>) and hash it.</li>
  <li>Then, we obtain Pool contract code (<code class="language-plaintext highlighter-rouge">type(UniswapV3Pool).creationCode</code>) and also hash it.</li>
  <li>Then, we build a sequence of bytes that includes: <code class="language-plaintext highlighter-rouge">0xff</code>, Factory contract address, hashed salt, and hashed Pool
contract code.</li>
  <li>We then hash the sequence and convert it to an address.</li>
</ol>

<p>These steps implement contract address generation as it’s defined in <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>,
which is the EIP that added <code class="language-plaintext highlighter-rouge">CREATE2</code> opcode. Let’s look closer at the values that constitute the hashed byte sequence:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">0xff</code>, as defined in the EIP, is used to distinguish addresses generated by <code class="language-plaintext highlighter-rouge">CREATE</code> and <code class="language-plaintext highlighter-rouge">CREATE2</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">factory</code> is the address of the deployer, in our case a Factory contract;</li>
  <li>salt was discussed earlier–it’s away to identify a unique Pool contract;</li>
  <li>hashed contract code is needed to protect from collisions: different contract can have the same salt, but their core
will be different.</li>
</ol>

<p>So, according to this scheme, a contract address is a hash of the values that uniquely identify this contract, including
its deployer, code, and unique parameters. We can use this function from anywhere to find out a pool address without
making any external calls and without querying the factory. Easy-peasy!</p>

<h2 id="simplified-interfaces-of-manager-and-quoter">Simplified Interfaces of Manager and Quoter</h2>

<p>In Manager and Quoter contracts, we no longer need to ask users for pool address! This makes interaction with the contracts
easier because users don’t need to know pool addresses, they only need to know tokens. However, users also need to specify
tick spacing because it’s included in pool’s salt.</p>

<p>Moreover, we no longer need to ask users for the <code class="language-plaintext highlighter-rouge">zeroForOne</code> flag because we can now always figure it out thanks to
tokens sorting. <code class="language-plaintext highlighter-rouge">zeroForOne</code> is true when “from token” is less than “to token”, since pool’s <code class="language-plaintext highlighter-rouge">token0</code> is always less than
<code class="language-plaintext highlighter-rouge">token1</code>. Likewise, <code class="language-plaintext highlighter-rouge">zeroForOne</code> is always false when “from token” is greater than “to token”.</p>

<blockquote>
  <p>Addresses are hashes, and hashes are numbers, so we can say “less than” or “greater that” when comparing addresses.</p>
</blockquote>
