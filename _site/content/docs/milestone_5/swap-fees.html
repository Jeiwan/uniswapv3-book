
<h1 id="swap-fees">Swap Fees</h1>

<p>As a mentioned in the introduction, swap fees is a core mechanism of Uniswap. Liquidity providers need to get paid for
the liquidity they provide, otherwise they’ll just use it somewhere else. To incentivize them, trades pay a small fee
during each swap. These fees then distributed among all liquidity providers pro rata (proportionally to their share).</p>

<p>To better understand the mechanism of fees collection and distribution, let’s see how they flow.</p>

<h2 id="how-swap-fees-are-collected">How Swap Fees are Collected</h2>

<p>[TODO: illustrate]</p>

<p>Swap fees are collected only when a price range is engaged (used in trades). So we need to track the moments when price
range boundaries get crossed. This is when a price range gets engaged and this is when we want to start collecting
fees for it:</p>
<ol>
  <li>when price is increasing and a tick is crossed from left to right;</li>
  <li>when price is decreasing and a tick is crossed from right to left.</li>
</ol>

<p>This is when a price range gets disengaged:</p>
<ol>
  <li>when price is increasing and a tick is crossed from right to left;</li>
  <li>when price is decreasing and a tick is crossed from left to right.</li>
</ol>

<p>[TODO: illustrate]</p>

<p>Besides knowing when a price range gets engaged/disengaged, we also want to keep track of how much fees each price
range accumulated.</p>

<p>To make fees accounting simpler, Uniswap V3 tracks <strong>the global fees generated by 1 unit of liquidity</strong>. Price range
fees are then calculated based on the global ones: fees accumulated outside of a price range are subtracted from the
global fees. Fees accumulated outside of a price range are tracked when a tick is crossed (and ticks are crossed when
swaps move the price; fees are collected during swaps). With this approach, we don’t need to update fees accumulated
by each position on very swap–this allows to save a lot of gas and make interaction with pools cheaper.</p>

<p>Let’s recap so we have a clear picture before moving on:</p>
<ol>
  <li>Fees are paid by users who swap tokens. A small amount is subtracted from input token and accumulated on pool’s
balance.</li>
  <li>Each pool has <code class="language-plaintext highlighter-rouge">feeGrowthGlobal0X128</code> and <code class="language-plaintext highlighter-rouge">feeGrowthGlobal1X128</code> state variables that track total accumulated fees per
unit of liquidity (that is, fee amount divided by pool’s liquidity).</li>
  <li>Notice that at this point actual positions are not updated to optimize gas usage.</li>
  <li>Ticks keep record of fees accumulated outside of them. When adding a new position and activating a tick (adding
liquidity to a previously empty tick), the tick records how much fees were accumulated outside of it (by convention,
we assume all fees were accumulated <strong>below the tick</strong>).</li>
  <li>Whenever a tick is activated, fees accumulated outside of the tick are updated as the difference between global fees
accumulated outside of the tick and the fees accumulated outside of the tick since the last time it was crossed.</li>
  <li>Having ticks that know how much fees were accumulated outside of them will allow us to calculated how much fees were
accumulated inside of a position (position is a range between two ticks).</li>
  <li>Knowing how much fees were accumulated inside a position will allow us to calculate the shares of fees liquidity
providers are eligible for. If a position wasn’t involved in swapping, it’ll have zero fees accumulated inside of it and
the liquidity providers who provided liquidity into this range will have no profits from it.</li>
</ol>

<p>Now, let’s see how to calculate fees accumulated by a position (step 6).</p>

<h2 id="calculating-position-accumulated-fees">Calculating Position Accumulated Fees</h2>

<p>To calculated total fees accumulated by a position, we need to consider two cases: when current price is inside the
position and when it’s outside of the position. In both cases, we subtract fees collected outside of the lower and the
upper ticks of the position from fees collected globally. However, we calculate those fees differently depending on
current price.</p>

<p>When current price is inside the position, we subtract the fees that have been collected outside of ticks by this moment:</p>

<p>[TODO: illustrate]</p>

<p>When current price is outside of the position, we need to update fees collected by either upper or lower ticks before
subtracting them from fees collecting globally. We update them only for the calculations and don’t overwrite them in
ticks because the ticks don’t get crossed.</p>

<p>This is how we update fees collected outside of a tick:</p>

\[f_{o}(i) = f_{g} - f_{o}(i)\]

<p>Fees collected outside of a tick ($f_{o}(i)$) is the difference between fees collected globally ($f_{g}$) and fees
collected outside of the tick when it crossed last time. We kind of reset the counter when a tick is crossed.</p>

<p>To calculate fees collected inside a position:</p>

\[f_{r} = f_{g} - f_{b}(i_{l}) - f_{a}(i_{u})\]

<p>We subtract fees collected below its lower tick ($f_{b}(i_{l})$) and above its upper tick ($f_{a}(i_{u})$) from fees
collected globally outside of the range ($f_{g}$). This is what we saw on the illustration above.</p>

<p>Now, when current price is above the lower tick (i.e. the position is engaged), we don’t need to update fees accumulated
below the lower tick and can simply take them from the lower tick. The same is true for fees collected outside of the
upper tick when current price is below upper tick. In the two other cases, we need to consider updated fees:</p>
<ol>
  <li>when taking fees collected below the lower tick and current price is also below the tick (the lower tick hasn’t been
crossed recently);</li>
  <li>when taking fees above the upper tick and current price is also above the tick (the upper tick hasn’t been crossed
recently).</li>
</ol>

<p>I hope this all is not too confusing. Luckily, we now know everything to start coding!</p>

<h2 id="collecting-fees-on-swaps">Collecting Fees on Swaps</h2>

<p>To keep it simple, we’ll add fees to our codebase step by step. And we’ll begin with fees collection.</p>

<h3 id="adding-required-state-variables">Adding Required State Variables</h3>
<p>First thing we need to do is to add the fee amount parameter to Pool–every pool will have a fixed, immutable, fee
configured during deployment. In the previous chapter, we added Factory contract that unified and simplified pools
deployment. One of the required pool parameters was tick spacing. Now, we’re going to replace it with fee amount and
we’ll tie fee amounts to tick spacing: the bigger the fee amount, the larger the tick spacing. This is so that low
volatility pools (stablecoin ones) have lower fees.</p>

<p>Let’s update Factory:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Factory.sol
</span><span class="k">contract</span> <span class="n">UniswapV3Factory</span> <span class="k">is</span> <span class="n">IUniswapV3PoolDeployer</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">uint24</span> <span class="o">=&gt;</span> <span class="kt">uint24</span><span class="p">)</span> <span class="k">public</span> <span class="n">fees</span><span class="p">;</span> <span class="c1">// `tickSpacings` replaced by `fees`
</span>
    <span class="k">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">fees</span><span class="p">[</span><span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">fees</span><span class="p">[</span><span class="mi">3000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">createPool</span><span class="p">(</span>
        <span class="kt">address</span> <span class="n">tokenX</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">tokenY</span><span class="p">,</span>
        <span class="kt">uint24</span> <span class="n">fee</span>
    <span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">PoolParameters</span><span class="p">({</span>
            <span class="n">factory</span><span class="o">:</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span>
            <span class="n">token0</span><span class="o">:</span> <span class="n">tokenX</span><span class="p">,</span>
            <span class="n">token1</span><span class="o">:</span> <span class="n">tokenY</span><span class="p">,</span>
            <span class="n">tickSpacing</span><span class="o">:</span> <span class="n">fees</span><span class="p">[</span><span class="n">fee</span><span class="p">],</span>
            <span class="n">fee</span><span class="o">:</span> <span class="n">fee</span>
        <span class="p">});</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Fee amounts are hundredths of a basis point. That is, 1 fee unit is 0.0001%, 500 is 0.05%, and 3000 is 0.3%.</p>

<p>Next step is to start accumulating fees in Pool. For that, we’ll add two global fee accumulator variables:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Pool.sol
</span><span class="k">contract</span> <span class="n">UniswapV3Pool</span> <span class="k">is</span> <span class="n">IUniswapV3Pool</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">uint24</span> <span class="k">public</span> <span class="kr">immutable</span> <span class="n">fee</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="k">public</span> <span class="n">feeGrowthGlobal0X128</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="k">public</span> <span class="n">feeGrowthGlobal1X128</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The one with index 0 tracks fees accumulated in <code class="language-plaintext highlighter-rouge">token0</code>, the one with index 1 tracks fees accumulated in <code class="language-plaintext highlighter-rouge">token1</code>.</p>

<h3 id="collecting-fees">Collecting Fees</h3>

<p>Now we need to update <code class="language-plaintext highlighter-rouge">SwapMath.computeSwapStep</code>–this is where we calculate swap amounts and this is also where
we’ll calculate and subtract swap fees. In the function, we replace all occurrences of <code class="language-plaintext highlighter-rouge">amountRemaining</code> with
<code class="language-plaintext highlighter-rouge">amountRemainingLessFee</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint256</span> <span class="n">amountRemainingLessFee</span> <span class="o">=</span> <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span>
    <span class="n">amountRemaining</span><span class="p">,</span>
    <span class="mi">1e6</span> <span class="o">-</span> <span class="n">fee</span><span class="p">,</span>
    <span class="mi">1e6</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Thus, we subtract the fee from input token amount and calculate output amount from a smaller input amount.</p>

<p>The function now also returns the fee amount collected during the step–it’s calculated differently depending on whether
the upper limit of the range was reached or not:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">max</span> <span class="o">=</span> <span class="n">sqrtPriceNextX96</span> <span class="o">==</span> <span class="n">sqrtPriceTargetX96</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">feeAmount</span> <span class="o">=</span> <span class="n">amountRemaining</span> <span class="o">-</span> <span class="n">amountIn</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">feeAmount</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">mulDivRoundingUp</span><span class="p">(</span><span class="n">amountIn</span><span class="p">,</span> <span class="n">fee</span><span class="p">,</span> <span class="mi">1e6</span> <span class="o">-</span> <span class="n">fee</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>When it’s not reached, the current price range has enough liquidity to fulfill the swap, thus we simply return the
difference between the amount we needed to fulfill and the actual amount fulfilled. Notice that <code class="language-plaintext highlighter-rouge">amountRemainingLessFee</code>
is not involved here since the actual final amount was calculated in <code class="language-plaintext highlighter-rouge">amountIn</code> (it’s calculated from actual liquidity).</p>

<p>When the target price is reached, we cannot subtract fees from the entire <code class="language-plaintext highlighter-rouge">amountRemaining</code> because the current price
range doesn’t have enough liquidity to fulfill the swap. Thus, fee amount is subtracted from the amount the current
price range has fulfilled (<code class="language-plaintext highlighter-rouge">amountIn</code>).</p>

<p>After <code class="language-plaintext highlighter-rouge">SwapMath.computeSwapStep</code> has returned, we need to update fees accumulated by the swap. Notice that there’s only
one variable to track them because, when staring a swap, we already know the input token:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SwapState</span> <span class="k">memory</span> <span class="n">state</span> <span class="o">=</span> <span class="n">SwapState</span><span class="p">({</span>
    <span class="p">...</span>
    <span class="n">feeGrowthGlobalX128</span><span class="o">:</span> <span class="n">zeroForOne</span>
        <span class="o">?</span> <span class="n">feeGrowthGlobal0X128</span>
        <span class="o">:</span> <span class="n">feeGrowthGlobal1X128</span>
<span class="p">});</span>

<span class="p">(...)</span> <span class="o">=</span> <span class="n">SwapMath</span><span class="p">.</span><span class="n">computeSwapStep</span><span class="p">(...);</span>

<span class="n">state</span><span class="p">.</span><span class="n">feeGrowthGlobalX128</span> <span class="o">+=</span> <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span>
    <span class="n">step</span><span class="p">.</span><span class="n">feeAmount</span><span class="p">,</span>
    <span class="n">FixedPoint128</span><span class="p">.</span><span class="n">Q128</span><span class="p">,</span>
    <span class="n">state</span><span class="p">.</span><span class="n">liquidity</span>
<span class="p">);</span>
</code></pre></div></div>

<p>This is where adjust collected fees by the amount of liquidity to later distribute fees among liquidity providers in a
fair way.</p>

<h3 id="updating-fee-trackers-in-ticks">Updating Fee Trackers in Ticks</h3>

<p>Next, we need to update the fee trackers in a tick, if it was crossed during a swap (crossing a tick means we’re entering
a new price range):</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">sqrtPriceX96</span> <span class="o">==</span> <span class="n">step</span><span class="p">.</span><span class="n">sqrtPriceNextX96</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int128</span> <span class="n">liquidityDelta</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span>
        <span class="n">step</span><span class="p">.</span><span class="n">nextTick</span><span class="p">,</span>
        <span class="p">(</span>
            <span class="n">zeroForOne</span>
                <span class="o">?</span> <span class="n">state</span><span class="p">.</span><span class="n">feeGrowthGlobalX128</span>
                <span class="o">:</span> <span class="n">feeGrowthGlobal0X128</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="n">zeroForOne</span>
                <span class="o">?</span> <span class="n">feeGrowthGlobal1X128</span>
                <span class="o">:</span> <span class="n">state</span><span class="p">.</span><span class="n">feeGrowthGlobalX128</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since we haven’t yet updated <code class="language-plaintext highlighter-rouge">feeGrowthGlobal0X128/feeGrowthGlobal1X128</code> state variables at this moment, we pass
<code class="language-plaintext highlighter-rouge">state.feeGrowthGlobalX128</code> as either of the fee parameters depending on swap direction. <code class="language-plaintext highlighter-rouge">cross</code> function updates the
fee trackers according to the logic we discussed above:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Tick.sol
</span><span class="k">function</span> <span class="n">cross</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthGlobal0X128</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthGlobal1X128</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">int128</span> <span class="n">liquidityDelta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">info</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">tick</span><span class="p">];</span>
    <span class="n">info</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span> <span class="o">=</span>
        <span class="n">feeGrowthGlobal0X128</span> <span class="o">-</span>
        <span class="n">info</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span><span class="p">;</span>
    <span class="n">info</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span> <span class="o">=</span>
        <span class="n">feeGrowthGlobal1X128</span> <span class="o">-</span>
        <span class="n">info</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span><span class="p">;</span>
    <span class="n">liquidityDelta</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">liquidityNet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>We haven’t added the initialization of <code class="language-plaintext highlighter-rouge">feeGrowthOutside0X128/feeGrowthOutside1X128</code> variables–we’ll do this in a later
step.</p>
</blockquote>

<h3 id="updating-global-fee-trackers">Updating Global Fee Trackers</h3>

<p>And, finally, after the swap is fulfilled, we can update the global fee trackers:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">zeroForOne</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">feeGrowthGlobal0X128</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">feeGrowthGlobalX128</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">feeGrowthGlobal1X128</span> <span class="o">=</span> <span class="n">state</span><span class="p">.</span><span class="n">feeGrowthGlobalX128</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Again, during a swap, only one of them is updated because fees are taken from the input token, which is either of <code class="language-plaintext highlighter-rouge">token0</code>
or <code class="language-plaintext highlighter-rouge">token1</code> depending on swap direction.</p>

<p>That’s it for swapping! Let’s now see what happens to fees when liquidity is added.</p>

<h2 id="fee-tracking-in-positions-management">Fee Tracking in Positions Management</h2>

<p>When adding or removing liquidity (we haven’t implemented the latter yet), we also need to initialize or update fees.
Fees need to be tracked both in ticks (fees accumulated outside of ticks) and positions (fees accumulated inside of
positions). In case of positions, we also need to keep track of and update the amounts of tokens collected as fees–or 
in other words, we convert fees per liquidity to token amounts. The latter is needed so that when a liquidity provider
removes liquidity, they get extra tokens collected as swap fees.</p>

<p>Let’s do it step by step again.</p>

<h3 id="initialization-of-fee-trackers-in-ticks">Initialization of Fee Trackers in Ticks</h3>

<p>In <code class="language-plaintext highlighter-rouge">Tick.update</code> function, whenever a tick is initialized (adding liquidity to a previously empty tick), we initialize
its fee trackers. However, we’re only doing so when the tick is below current price, i.e. when it’s inside of the current
price range:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Tick.sol
</span><span class="k">function</span> <span class="n">update</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">currentTick</span><span class="p">,</span>
    <span class="kt">int128</span> <span class="n">liquidityDelta</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthGlobal0X128</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthGlobal1X128</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">upper</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">flipped</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">liquidityBefore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// by convention, assume that all previous fees were collected below
</span>        <span class="c1">// the tick
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">tick</span> <span class="o">&lt;=</span> <span class="n">currentTick</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tickInfo</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span> <span class="o">=</span> <span class="n">feeGrowthGlobal0X128</span><span class="p">;</span>
            <span class="n">tickInfo</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span> <span class="o">=</span> <span class="n">feeGrowthGlobal1X128</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">tickInfo</span><span class="p">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If it’s not inside of the current price range, its fee trackers will be 0 and they’ll be update when the tick is crossed
next time.</p>

<h3 id="updating-position-fees-and-token-amounts">Updating Position Fees and Token Amounts</h3>

<p>Next step is to calculate the fees and tokens accumulated by a position. Since a position is a range between two ticks,
we’ll calculated these values using the fee trackers we added to ticks on the previous step. The next function might
look messy, but it’s implements the exact price range fee formulas we saw earlier:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Tick.sol
</span><span class="k">function</span> <span class="n">getFeeGrowthInside</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">lowerTick_</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">upperTick_</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">currentTick</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthGlobal0X128</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthGlobal1X128</span>
<span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">view</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">feeGrowthInside0X128</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">feeGrowthInside1X128</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">lowerTick</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">lowerTick_</span><span class="p">];</span>
    <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">upperTick</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">upperTick_</span><span class="p">];</span>

    <span class="kt">uint256</span> <span class="n">feeGrowthBelow0X128</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthBelow1X128</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentTick</span> <span class="o">&gt;=</span> <span class="n">lowerTick_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">feeGrowthBelow0X128</span> <span class="o">=</span> <span class="n">lowerTick</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span><span class="p">;</span>
        <span class="n">feeGrowthBelow1X128</span> <span class="o">=</span> <span class="n">lowerTick</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">feeGrowthBelow0X128</span> <span class="o">=</span>
            <span class="n">feeGrowthGlobal0X128</span> <span class="o">-</span>
            <span class="n">lowerTick</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span><span class="p">;</span>
        <span class="n">feeGrowthBelow1X128</span> <span class="o">=</span>
            <span class="n">feeGrowthGlobal0X128</span> <span class="o">-</span>
            <span class="n">lowerTick</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint256</span> <span class="n">feeGrowthAbove0X128</span><span class="p">;</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthAbove1X128</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentTick</span> <span class="o">&lt;</span> <span class="n">upperTick_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">feeGrowthAbove0X128</span> <span class="o">=</span> <span class="n">upperTick</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span><span class="p">;</span>
        <span class="n">feeGrowthAbove1X128</span> <span class="o">=</span> <span class="n">upperTick</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">feeGrowthAbove0X128</span> <span class="o">=</span>
            <span class="n">feeGrowthGlobal0X128</span> <span class="o">-</span>
            <span class="n">upperTick</span><span class="p">.</span><span class="n">feeGrowthOutside0X128</span><span class="p">;</span>
        <span class="n">feeGrowthAbove1X128</span> <span class="o">=</span>
            <span class="n">feeGrowthGlobal0X128</span> <span class="o">-</span>
            <span class="n">upperTick</span><span class="p">.</span><span class="n">feeGrowthOutside1X128</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">feeGrowthInside0X128</span> <span class="o">=</span>
        <span class="n">feeGrowthGlobal0X128</span> <span class="o">-</span>
        <span class="n">feeGrowthBelow0X128</span> <span class="o">-</span>
        <span class="n">feeGrowthAbove0X128</span><span class="p">;</span>
    <span class="n">feeGrowthInside1X128</span> <span class="o">=</span>
        <span class="n">feeGrowthGlobal1X128</span> <span class="o">-</span>
        <span class="n">feeGrowthBelow1X128</span> <span class="o">-</span>
        <span class="n">feeGrowthAbove1X128</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, we’re calculating fees accumulated between two ticks (inside a price range). For this, we first calculate fees
accumulated below the lower tick and then fees calculated above the upper tick. In the end, we subtract those fees from
the globally accumulated ones. This is the formula we saw earlier:</p>

\[f_{r} = f_{g} - f_{b}(i_{l}) - f_{a}(i_{u})\]

<p>After finding the fees accumulated inside of a position, we’re ready to update fee and token amounts trackers of the
position:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/lib/Position.sol
</span><span class="k">function</span> <span class="n">update</span><span class="p">(</span>
    <span class="n">Info</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int128</span> <span class="n">liquidityDelta</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthInside0X128</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="n">feeGrowthInside1X128</span>
<span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
    <span class="kt">uint128</span> <span class="n">tokensOwed0</span> <span class="o">=</span> <span class="kt">uint128</span><span class="p">(</span>
        <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span>
            <span class="n">feeGrowthInside0X128</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">feeGrowthInside0LastX128</span><span class="p">,</span>
            <span class="n">self</span><span class="p">.</span><span class="n">liquidity</span><span class="p">,</span>
            <span class="n">FixedPoint128</span><span class="p">.</span><span class="n">Q128</span>
        <span class="p">)</span>
    <span class="p">);</span>
    <span class="kt">uint128</span> <span class="n">tokensOwed1</span> <span class="o">=</span> <span class="kt">uint128</span><span class="p">(</span>
        <span class="n">PRBMath</span><span class="p">.</span><span class="n">mulDiv</span><span class="p">(</span>
            <span class="n">feeGrowthInside1X128</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">feeGrowthInside1LastX128</span><span class="p">,</span>
            <span class="n">self</span><span class="p">.</span><span class="n">liquidity</span><span class="p">,</span>
            <span class="n">FixedPoint128</span><span class="p">.</span><span class="n">Q128</span>
        <span class="p">)</span>
    <span class="p">);</span>

    <span class="n">self</span><span class="p">.</span><span class="n">liquidity</span> <span class="o">=</span> <span class="n">LiquidityMath</span><span class="p">.</span><span class="n">addLiquidity</span><span class="p">(</span>
        <span class="n">self</span><span class="p">.</span><span class="n">liquidity</span><span class="p">,</span>
        <span class="n">liquidityDelta</span>
    <span class="p">);</span>
    <span class="n">self</span><span class="p">.</span><span class="n">feeGrowthInside0LastX128</span> <span class="o">=</span> <span class="n">feeGrowthInside0X128</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">feeGrowthInside1LastX128</span> <span class="o">=</span> <span class="n">feeGrowthInside1X128</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tokensOwed0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tokensOwed1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tokensOwed0</span> <span class="o">+=</span> <span class="n">tokensOwed0</span><span class="p">;</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tokensOwed1</span> <span class="o">+=</span> <span class="n">tokensOwed1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When calculating owed tokens, we multiply fees accumulated by the position by liquidity–the reverse of what we did
during swapping. In the end, we update the fee trackers and add the token amounts to the previously tracked ones.</p>

<p>Now, whenever a position is modified (during addition or removal of liquidity), we calculate fees collected by a
position and update the position:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/UniswapV3Pool.sol
</span><span class="k">function</span> <span class="n">mint</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">bool</span> <span class="n">flippedLower</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">lowerTick</span><span class="p">,</span> <span class="p">...);</span>
    <span class="kt">bool</span> <span class="n">flippedUpper</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">upperTick</span><span class="p">,</span> <span class="p">...);</span>
    <span class="p">...</span>
    <span class="p">(</span><span class="kt">uint256</span> <span class="n">feeGrowthInside0X128</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">feeGrowthInside1X128</span><span class="p">)</span> <span class="o">=</span> <span class="n">ticks</span>
        <span class="p">.</span><span class="n">getFeeGrowthInside</span><span class="p">(</span>
            <span class="n">params</span><span class="p">.</span><span class="n">lowerTick</span><span class="p">,</span>
            <span class="n">params</span><span class="p">.</span><span class="n">upperTick</span><span class="p">,</span>
            <span class="n">slot0_</span><span class="p">.</span><span class="n">tick</span><span class="p">,</span>
            <span class="n">feeGrowthGlobal0X128_</span><span class="p">,</span>
            <span class="n">feeGrowthGlobal1X128_</span>
        <span class="p">);</span>

    <span class="n">position</span><span class="p">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">params</span><span class="p">.</span><span class="n">liquidityDelta</span><span class="p">,</span>
        <span class="n">feeGrowthInside0X128</span><span class="p">,</span>
        <span class="n">feeGrowthInside1X128</span>
    <span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="removing-liquidity">Removing Liquidity</h2>

<p>We’re now ready to add the only core feature we haven’t implemented yet–removal of liquidity. As opposed to minting,
we’ll call this function <code class="language-plaintext highlighter-rouge">burn</code>. This is the function that will let liquidity providers remove a fraction of or whole
liquidity from a position they previously added liquidity to. In addition to that, it’ll also calculate the fee tokens
liquidity providers are eligible for. However, actual transferring of tokens will be done in a separate function–
<code class="language-plaintext highlighter-rouge">collect</code>.</p>

<h3 id="burning-liquidity">Burning Liquidity</h3>

<p>Burning liquidity is opposed to minting. Our current design and implementation makes it a hassle-free task: burning
liquidity is simply minting with the negative sign. It’s like adding a negative amount of liquidity.</p>

<blockquote>
  <p>To implement <code class="language-plaintext highlighter-rouge">burn</code>,  I needed to refactor the code and extract everything related to position management (updating
ticks and position, and token amounts calculation) into <code class="language-plaintext highlighter-rouge">_modifyPosition</code> function, which is used by both <code class="language-plaintext highlighter-rouge">mint</code> and
<code class="language-plaintext highlighter-rouge">burn</code> function.</p>
</blockquote>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">burn</span><span class="p">(</span>
    <span class="kt">int24</span> <span class="n">lowerTick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">upperTick</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">amount</span>
<span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount1</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span>
        <span class="n">Position</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">position</span><span class="p">,</span>
        <span class="kt">int256</span> <span class="n">amount0Int</span><span class="p">,</span>
        <span class="kt">int256</span> <span class="n">amount1Int</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_modifyPosition</span><span class="p">(</span>
            <span class="n">ModifyPositionParams</span><span class="p">({</span>
                <span class="n">owner</span><span class="o">:</span> <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span>
                <span class="n">lowerTick</span><span class="o">:</span> <span class="n">lowerTick</span><span class="p">,</span>
                <span class="n">upperTick</span><span class="o">:</span> <span class="n">upperTick</span><span class="p">,</span>
                <span class="n">liquidityDelta</span><span class="o">:</span> <span class="o">-</span><span class="p">(</span><span class="kt">int128</span><span class="p">(</span><span class="n">amount</span><span class="p">))</span>
            <span class="p">})</span>
        <span class="p">);</span>

    <span class="n">amount0</span> <span class="o">=</span> <span class="kt">uint256</span><span class="p">(</span><span class="o">-</span><span class="n">amount0Int</span><span class="p">);</span>
    <span class="n">amount1</span> <span class="o">=</span> <span class="kt">uint256</span><span class="p">(</span><span class="o">-</span><span class="n">amount1Int</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">tokensOwed0</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed0</span> <span class="o">+</span> <span class="kt">uint128</span><span class="p">(</span><span class="n">amount0</span><span class="p">),</span>
            <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed1</span> <span class="o">+</span> <span class="kt">uint128</span><span class="p">(</span><span class="n">amount1</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">emit</span> <span class="n">Burn</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">lowerTick</span><span class="p">,</span> <span class="n">upperTick</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">amount0</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">burn</code> function, we first update a position and remove some amount of liquidity from it. Then, we update the token
amount owed by the position–they now include amounts accumulated via fees as well as amounts that were previously
provided as liquidity. We can also see this as conversion of position liquidity into token amounts owed by the position–
these amounts won’t be used as liquidity anymore and can be freely redeemed by calling <code class="language-plaintext highlighter-rouge">collect</code> function.</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">collect</span><span class="p">(</span>
    <span class="kt">address</span> <span class="n">recipient</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">lowerTick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">upperTick</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">amount0Requested</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">amount1Requested</span>
<span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint128</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">uint128</span> <span class="n">amount1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Position</span><span class="p">.</span><span class="n">Info</span> <span class="k">memory</span> <span class="n">position</span> <span class="o">=</span> <span class="n">positions</span><span class="p">.</span><span class="n">get</span><span class="p">(</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span>
        <span class="n">lowerTick</span><span class="p">,</span>
        <span class="n">upperTick</span>
    <span class="p">);</span>

    <span class="n">amount0</span> <span class="o">=</span> <span class="n">amount0Requested</span> <span class="o">&gt;</span> <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed0</span>
        <span class="o">?</span> <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed0</span>
        <span class="o">:</span> <span class="n">amount0Requested</span><span class="p">;</span>
    <span class="n">amount1</span> <span class="o">=</span> <span class="n">amount1Requested</span> <span class="o">&gt;</span> <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed1</span>
        <span class="o">?</span> <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed1</span>
        <span class="o">:</span> <span class="n">amount1Requested</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed0</span> <span class="o">-=</span> <span class="n">amount0</span><span class="p">;</span>
        <span class="n">IERC20</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">amount0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">position</span><span class="p">.</span><span class="n">tokensOwed1</span> <span class="o">-=</span> <span class="n">amount1</span><span class="p">;</span>
        <span class="n">IERC20</span><span class="p">(</span><span class="n">token1</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">emit</span> <span class="n">Collect</span><span class="p">(</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span>
        <span class="n">recipient</span><span class="p">,</span>
        <span class="n">lowerTick</span><span class="p">,</span>
        <span class="n">upperTick</span><span class="p">,</span>
        <span class="n">amount0</span><span class="p">,</span>
        <span class="n">amount1</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function simply transfers tokens from a pool and ensures that only valid amounts can be transferred (one cannot
transfer out more than they burned + fees).</p>

<p>There’s also a way to collect fees only without burning liquidity: burn 0 amount of liquidity and then call <code class="language-plaintext highlighter-rouge">collect</code>.
During burning, the position will be updated and token amounts it owes will be updated as well.</p>

<p>And, that’s it! Our pool implementation is complete now!</p>
