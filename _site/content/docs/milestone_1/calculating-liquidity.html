
<h1 id="calculating-liquidity">Calculating liquidity</h1>

<p>Trading is not possible without liquidity, and to make our first swap we need to put some liquidity into the pool contract.
Here&#8217;s what we need to know to add liquidity to the pool contract:</p>

<ol>
  <li>A price range. As a liquidity provider, we want to provide liquidity at a specific price range, and it&#8217;ll only be used
in this range.</li>
  <li>Amount of liquidity, which is the amounts of two tokens. We&#8217;ll need to transfer these amounts to the pool contract.</li>
</ol>

<p>Here, we&#8217;re going to calculate these manually, but, in a later chapter, a contract will do this for us. Let&#8217;s begin with
a price range.</p>

<h2 id="price-range-calculation">Price Range Calculation</h2>

<p>Recall that, in Uniswap V3, the entire price range is demaracted into <em>ticks</em>: each tick corresponds to a price and has
an index. In our first pool implementation, we&#8217;re going to buy ETH for USDC at the price of <span>$5000</span> per 1 ETH.
Buying ETH will remove some amount of it from the pool and will push the price slightly above <span>$5000</span>.
We want to provide liquidity at a range that includes this price. And we want to be sure that the final price will stay
<strong>within this range</strong> (we&#8217;ll do multi-range swaps in a later chapter).</p>

<p>We&#8217;ll need to find three ticks:</p>
<ol>
  <li>The current tick will correspond to the current price (5000 USDC for 1 ETH).</li>
  <li>The lower and upper bounds of the price range we&#8217;re providing liquidity into. Let the lower price be <span>$4500</span>
and the upper price be <span>$5500</span>.</li>
</ol>

<p>From the theoretical introduction we know that:</p>

\[\sqrt{p} = \sqrt{\frac{y}{x}}\]

<p>Since we&#8217;ve agreed to use ETH as the $x$ reserve and USDC as the $y$ reserve, the prices at each of the ticks are:</p>

\[\sqrt{p_c} = \sqrt{\frac{5000}{1}} = \sqrt{5000} \approx 70.71\]

\[\sqrt{p_l} = \sqrt{\frac{4545}{1}} \approx 67.42\]

\[\sqrt{p_u} = \sqrt{\frac{5500}{1}} \approx 74.16\]

<p>Where $p_c$ is the current price, $p_l$ is the lower bound of the range, $p_u$ is the upper bound of the range.</p>

<p>Now, we can find corresponding ticks. We know that prices and ticks are connected via this formula:</p>

\[\sqrt{p(i)}=1.0001^{\frac{i}{2}}\]

<p>Thus, we can find tick $i$ via:</p>

\[i = log_{\sqrt{1.0001}} \sqrt{p(i)}\]

<blockquote>
  <p>The square roots in this formula cancel out, but since we&#8217;re working with $\sqrt{p}$ we need to preserve them.</p>
</blockquote>

<p>Let&#8217;s find the ticks:</p>
<ol>
  <li>Current tick: $i_c = log_{\sqrt{1.0001}} 70.71 = 85176$</li>
  <li>Lower tick: $i_l = log_{\sqrt{1.0001}} 67.42 = 84222$</li>
  <li>Upper tick: $i_u = log_{\sqrt{1.0001}} 74.16 = 86129$</li>
</ol>

<blockquote>
  <p>To calculate these, I used Python:</p>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">price_to_tick</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mf">1.0001</span><span class="p">))</span>

<span class="n">price_to_tick</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mi">85176</span>
</code></pre></div>  </div>
  <p>(Feel free using any other language.)</p>
</blockquote>

<p>That&#8217;s it for price range calculation!</p>

<p>Last thing to note here is that Uniswap uses Q64.96 number to store $\sqrt{p}$. This is a fixed point number that has
64 bits for the integer part and 96 bits for the fractional part. In our above calculations, prices are floating point
numbers: <code class="language-plaintext highlighter-rouge">70.71</code>, <code class="language-plaintext highlighter-rouge">67.42</code>, <code class="language-plaintext highlighter-rouge">74.16</code>. We need to convert them to Q64.96. Luckily, this is simple: we need to multiply the
numbers by the maximum value of the fractional part of Q64.96, which is $2^{96}$. We&#8217;ll get:</p>

\[\sqrt{p_c} = 5602277097478614198912276234240\]

\[\sqrt{p_l} = 5314786713428871004159001755648\]

\[\sqrt{p_u} = 5875717789736564987741329162240\]

<blockquote>
  <p>In Python:</p>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q96</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">96</span>
<span class="k">def</span> <span class="nf">price_to_sqrtp</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">q96</span><span class="p">)</span>

<span class="n">price_to_sqrtp</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mi">5602277097478614198912276234240</span>
</code></pre></div>  </div>
  <p>Notice that we&#8217;re multiplying before converting to integer. Otherwise, we&#8217;ll use precision.</p>
</blockquote>

<p>Ok, we&#8217;re done here.</p>

<h2 id="token-amounts-calculation">Token Amounts Calculation</h2>

<p>Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts
are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without causing the price
leave the price range we put liquidity into. During development and testing we&#8217;ll be able to mint any amount of tokens,
so getting the amounts we want is not a problem.</p>

<p>For our first swap, let&#8217;s deposit 1 ETH and 5000 USDC.</p>

<h2 id="liquidity-amount-calculation">Liquidity Amount Calculation</h2>

<p>Next, we need to calculate $L$ based on the amounts we&#8217;ll deposit.</p>

<p>From the theoretical introduction, you remember that:
\(L = \sqrt{xy}\)</p>

<p>However, we cannot simply multiply 1 ETH by 5000 USDC and take the square root. The reason is that the $x$ and $y$ in this
formula are <strong>virtual reserves</strong>.
[TODO: what are virtual reserves?]</p>

<p>We need to calculate $L$ specifically for the price range we&#8217;re going to deposit liquidity into, and it&#8217;ll be calculated
based on the amounts we&#8217;re going to deposit. To find $L$, we need to look at one interesting fact: when the current price
equals the lower or the upper price, <strong>one of the pool reserves is 0 and all pool&#8217;s liquidity is in the other reserve</strong>.
For example, if the current price is <span>$5500</span> then all ETH was bought from the pool and there&#8217;s only USDC left.
And vice versa: when the current price is <span>$4500</span> then all USDC was bought from the pool and there&#8217;s only ETH.</p>

<p>[TODO: illustrate]</p>

<p>[TODO: or maybe use the delta x and delta y formulas?]
\(\Delta x = \frac{L}{\sqrt{p(i_u)}} - \frac{L}{\sqrt{p(i_c)}} = \frac{L(\sqrt{p(i_u)} - \sqrt{p(i_c)})}{\sqrt{p(i_u)}\sqrt{p(i_c)}}\)
\(\Delta y = L\sqrt{p(i_c)} - L\sqrt{p(i_l)} = L(\sqrt{p(i_c)} - \sqrt{p(i_l)})\)</p>

<p>Knowing this, let&#8217;s return to the trading formula of real reserves:</p>

\[(x + \frac{L}{\sqrt{p_b}})(y + L\sqrt{p_a}) = L^{2}\]

<p>So, there are two possible situations:</p>
<ol>
  <li>$x$ can be 0 when the entire reserve of $x$ is bought from the pool.</li>
  <li>$y$ can be 0 when the entire reserve of $y$ is bought from the pool.</li>
</ol>

<p>And these situations also serve as constraints: the amount of $L$ we deposit <strong>must</strong> satisfy both of them.</p>

<p>So, to find $L$, we need to calculate it in both of these scenarios. Let&#8217;s begin with the one where $y$ is zero. The
trade function will look like so:</p>

\[(x+\frac{L}{\sqrt{p_b}})L\sqrt{p_a} = L^{2}\]

<p>When $y$ is zero, any trade will add some $\Delta y$ ($L\sqrt{p_a}$) to the empty reserve of $y$, and no buying of $y$ in
this situation is possible.</p>

<p>Next, we can find $L$:</p>

\[L = x\frac{\sqrt{p_a}\sqrt{p_b}}{\sqrt{p_b}-\sqrt{p_a}}\]

<p>Now, let&#8217;s find a similar formula for the situation when $x$ is zero:</p>

<p>\(\frac{L}{\sqrt{p_b}}(y + L\sqrt{p_a}) = L^{2}\)
\(L = \frac{y}{\sqrt{p_b}-\sqrt{p_a}}\)</p>

<p>[TODO: show the calculations]</p>

<p>Having these two $L&#8217;s$, we need to choose one of them and we&#8217;ll choose the smaller one. Why? The amount of liquidity
we deposit must allow equally big price movements in both directions. If we pick the bigger amount, the other on won&#8217;t
be enough to satisfy this requirement.</p>

<p>Now, let&#8217;s plug our numbers into the formulas. For $x$, $p_a$ is the current price, and $p_b$ is the upper bound of the
price range. For $y$, $p_a$ is the lower bound and $p_b$ is the current price.</p>

<p>[TODO: add graph, x_real, y_real, from the whitepaper]</p>

<p>\(L = x\frac{\sqrt{p_a}\sqrt{p_b}}{\sqrt{p_b}-\sqrt{p_a}} = 1 ETH * \frac{67.42 * 70.71}{70.71 - 67.42}\)
After converting to Q64.96, we get:</p>

\[L = 1519437308014769733632\]

<p>Solving the other $L$:
\(L = \frac{y}{\sqrt{p_b}-\sqrt{p_a}} = \frac{5000USDC}{74.16-70.71}\)
\(L = 1517882343751509868544\)</p>

<blockquote>
  <p>In Python:</p>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sqrtp_low</span> <span class="o">=</span> <span class="n">price_to_sqrtp</span><span class="p">(</span><span class="mi">4545</span><span class="p">)</span>
<span class="n">sqrtp_cur</span> <span class="o">=</span> <span class="n">price_to_sqrtp</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">sqrtp_upp</span> <span class="o">=</span> <span class="n">price_to_sqrtp</span><span class="p">(</span><span class="mi">5500</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">liquidity0</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pa</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="p">:</span>
        <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pa</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">amount</span> <span class="o">*</span> <span class="p">(</span><span class="n">pa</span> <span class="o">*</span> <span class="n">pb</span><span class="p">)</span> <span class="o">/</span> <span class="n">q96</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">liquidity1</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pa</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="p">:</span>
        <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pa</span>
    <span class="k">return</span> <span class="n">amount</span> <span class="o">*</span> <span class="n">q96</span> <span class="o">/</span> <span class="p">(</span><span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span>

<span class="n">liq0</span> <span class="o">=</span> <span class="n">liquidity0</span><span class="p">(</span><span class="n">amount_eth</span><span class="p">,</span> <span class="n">sqrtp_cur</span><span class="p">,</span> <span class="n">sqrtp_upp</span><span class="p">)</span>
<span class="n">liq1</span> <span class="o">=</span> <span class="n">liquidity1</span><span class="p">(</span><span class="n">amount_usdc</span><span class="p">,</span> <span class="n">sqrtp_cur</span><span class="p">,</span> <span class="n">sqrtp_low</span><span class="p">)</span>
<span class="n">liq</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">liq0</span><span class="p">,</span> <span class="n">liq1</span><span class="p">))</span>
<span class="o">&gt;</span> <span class="mi">1517882343751509868544</span>
</code></pre></div>  </div>
</blockquote>

<p>Of these two we&#8217;re picking the smaller one, <code class="language-plaintext highlighter-rouge">1517882343751509868544</code>.</p>

<h2 id="token-amounts-calculation-again">Token Amounts Calculation, Again</h2>

<p>Since we choose the amounts we&#8217;re going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price
ranges; liquidity amounts need to aligned with the shape of curve in the price range we&#8217;re depositing into. Thus, even
though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at
least because of rounding). Luckily, we can re-use the formulas from the previous paragraph:</p>

<p>\(L = x\frac{\sqrt{p_a}\sqrt{p_b}}{\sqrt{p_b}-\sqrt{p_a}}\)
\(L = \frac{y}{\sqrt{p_b}-\sqrt{p_a}}\)</p>

<p>From them, we can find $x$ and $y$:</p>

<p>\(x = \frac{L(\sqrt{p_b}-\sqrt{p_a})}{\sqrt{p_b}\sqrt{p_a}}\)
\(y = L(\sqrt{p_b}-\sqrt{p_a})\)</p>

<blockquote>
  <p>In Python:</p>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calc_amount0</span><span class="p">(</span><span class="n">liq</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pa</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="p">:</span>
        <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pa</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">liq</span> <span class="o">*</span> <span class="n">q96</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span> <span class="o">/</span> <span class="n">pa</span> <span class="o">/</span> <span class="n">pb</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">calc_amount1</span><span class="p">(</span><span class="n">liq</span><span class="p">,</span> <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pa</span> <span class="o">&gt;</span> <span class="n">pb</span><span class="p">:</span>
        <span class="n">pa</span><span class="p">,</span> <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="p">,</span> <span class="n">pa</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">liq</span> <span class="o">*</span> <span class="p">(</span><span class="n">pb</span> <span class="o">-</span> <span class="n">pa</span><span class="p">)</span> <span class="o">/</span> <span class="n">q96</span><span class="p">)</span>

<span class="n">amount0</span> <span class="o">=</span> <span class="n">calc_amount0</span><span class="p">(</span><span class="n">liq</span><span class="p">,</span> <span class="n">sqrtp_upp</span><span class="p">,</span> <span class="n">sqrtp_cur</span><span class="p">)</span>
<span class="n">amount1</span> <span class="o">=</span> <span class="n">calc_amount1</span><span class="p">(</span><span class="n">liq</span><span class="p">,</span> <span class="n">sqrtp_low</span><span class="p">,</span> <span class="n">sqrtp_cur</span><span class="p">)</span>
<span class="p">(</span><span class="n">amount0</span><span class="p">,</span> <span class="n">amount1</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="mi">998976618347425408</span><span class="p">,</span> <span class="mi">5000000000000000000000</span><span class="p">)</span>
</code></pre></div>  </div>
  <p>As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller.</p>
</blockquote>

<blockquote>
  <p><strong>Hint</strong>: use <code class="language-plaintext highlighter-rouge">cast --from-wei AMOUNT</code> to convert from wei to ether. For example:<br />
<code class="language-plaintext highlighter-rouge">cast --from-wei 998976618347425280</code> will give you <code class="language-plaintext highlighter-rouge">0.998976618347425280</code>.</p>
</blockquote>

<p>To sum it up, when providing liquidity, users:</p>
<ol>
  <li>choose the price range they want to provide liquidity into,</li>
  <li>choose the amounts of tokens they want to provide.</li>
</ol>

<p>Contracts then:</p>
<ol>
  <li>calculate $L$ based on the amounts and the price range chosen by the user,</li>
  <li>calculate exact amounts the user needs to deposit.</li>
</ol>

<p>The amounts users choose are upper bounds, and contracts guarantee that users won&#8217;t send more tokens than they&#8217;ve chosen.
We&#8217;ll see how this works in a later milestone.</p>
