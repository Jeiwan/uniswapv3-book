<h1 id="deployment">Deployment</h1>

<p>Alright, our contract is done. Now, let’s see how we can deploy it to a local Ethereum network so we could use it from
a front-end app later on.</p>

<h2 id="choosing-local-blockchain-network">Choosing Local Blockchain Network</h2>

<p>Smart contracts development requires running a local network, where you deploy your contracts during development and
testing. This is what we want from such a network:</p>
<ol>
  <li>Real blockchain. It must be a real Ethereum network, not an emulation. We want to be sure that our contract will work
in the local network exactly as it would in the mainnet.</li>
  <li>Speed. We want our transactions to be minted immediately, so we could iterate quickly.</li>
  <li>Ether. To pay transaction fees, we need some ether, and we want the local network to allow us to generate any amount
of ether.</li>
  <li>Cheat codes. Besides providing the standard API, we want a local network to allow us to do more. For example, we want
to be able to deploy contracts at any address, execute transactions from any address (impersonate other address), change
contract state directly, etc.</li>
</ol>

<p>There are multiple solutions as of today:</p>
<ol>
  <li><a href="https://trufflesuite.com/ganache/">Ganache</a> from Truffle Suite.</li>
  <li><a href="https://hardhat.org/">Hardhat</a>, which is a development environment that includes a local node besides other useful
things.</li>
  <li><a href="https://github.com/foundry-rs/foundry/tree/master/anvil">Anvil</a> from Foundry.</li>
</ol>

<p>All of these are viable solutions and each of them will satisfy our needs. Having said that, projects have been slowly
migrating from Ganache (which is the oldest of the solutions) to Hardhat (which seems to be the most widely used these
days), and now there’s the new kid on the block: Foundry. Foundry is also the only of these solutions that uses Solidity
for writing tests (the others use JavaScript). Moreover, Foundry also allows to write deployment scripts in Solidity.
Thus, since we’ve decided to use Solidity everywhere, we’ll use Anvil to run a local development blockchain, and we’ll
write deployment scripts in Solidity.</p>

<h2 id="running-local-blockchain">Running Local Blockchain</h2>

<p>Anvil doesn’t require configuration, we can run it with a single command and it’ll do:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>anvil
                             _   _
                            <span class="o">(</span>_<span class="o">)</span> | |
      __ _   _ __   __   __  _  | |
     / _<span class="sb">`</span> | | <span class="s1">'_ \  \ \ / / | | | |
    | (_| | | | | |  \ V /  | | | |
     \__,_| |_| |_|   \_/   |_| |_|

    0.1.0 (d89f6af 2022-06-24T00:15:17.897682Z)
    https://github.com/foundry-rs/foundry
...
Listening on 127.0.0.1:8545
</span></code></pre></div></div>

<p>Anvil runs a single Ethereum node, so this is not really a network, but that’s ok. By default, it creates 10 accounts
with 10,000 ETH in each of them. It prints the addresses and related private keys when it starts–we’ll be using one of
these addresses when deploying and interacting with the contract from UI.</p>

<p>Anvil exposes JSON-RPC API interface at <code class="language-plaintext highlighter-rouge">127.0.0.1:8545</code>–this interface is the main way of interacting with Ethereum
nodes. You can find full API reference <a href="https://ethereum.org/en/developers/docs/apis/json-rpc/">here</a>. And this is how
you can call it via <code class="language-plaintext highlighter-rouge">curl</code>:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"id":1,"jsonrpc":"2.0","method":"eth_chainId"}'</span> <span class="se">\</span>
  http://127.0.0.1:8545
<span class="o">{</span><span class="s2">"jsonrpc"</span>:<span class="s2">"2.0"</span>,<span class="s2">"id"</span>:1,<span class="s2">"result"</span>:<span class="s2">"0x7a69"</span><span class="o">}</span>
<span class="nv">$ </span>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"id":1,"jsonrpc":"2.0","method":"eth_getBalance","params":["0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266","latest"]}'</span> <span class="se">\</span>
  http://127.0.0.1:8545
<span class="o">{</span><span class="s2">"jsonrpc"</span>:<span class="s2">"2.0"</span>,<span class="s2">"id"</span>:1,<span class="s2">"result"</span>:<span class="s2">"0x21e19e0c9bab2400000"</span><span class="o">}</span>
</code></pre></div></div>

<p>You can also use <code class="language-plaintext highlighter-rouge">cast</code> (part of Foundry) for that:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cast chain-id
31337
<span class="nv">$ </span>cast balance 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
10000000000000000000000
</code></pre></div></div>

<p>Now, let’s deploy the pool and manager contracts to the local network.</p>

<h2 id="first-deployment">First Deployment</h2>

<p>At its core, deploying a contract means:</p>
<ol>
  <li>Compiling source code into EVM bytecode.</li>
  <li>Sending a transaction with the bytecode.</li>
  <li>Creating a new address, executing the constructor par of the bytecode, storing initialized bytecode on the address.
This step is done automatically by an Ethereum node, when your transaction is mined.</li>
</ol>

<p>Deployment usually consists of multiple steps: preparing parameters, deploying auxiliary contracts, deploying main
contracts, initializing contracts, etc. To automate these steps, scripting is used. As you might’ve already guessed,
we’ll write scripts in Solidity!</p>

<p>Create <code class="language-plaintext highlighter-rouge">scripts/DeployDevelopment.sol</code> contract with this content:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: UNLICENSED
</span><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">14</span><span class="p">;</span>

<span class="k">import</span> <span class="s">"forge-std/Script.sol"</span><span class="p">;</span>

<span class="k">contract</span> <span class="n">DeployDevelopment</span> <span class="k">is</span> <span class="n">Script</span> <span class="p">{</span>
    <span class="k">function</span> <span class="n">run</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
      <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It looks very similar to the test contract, besides the fact that it inherits from <code class="language-plaintext highlighter-rouge">Script</code> contract, not from <code class="language-plaintext highlighter-rouge">Test</code>.
And, by convention, we need to define <code class="language-plaintext highlighter-rouge">run</code> function which will be the body of our deployment script. In the <code class="language-plaintext highlighter-rouge">run</code>
function, we define the parameters of the deployment first:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint256</span> <span class="n">wethBalance</span> <span class="o">=</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">;</span>
<span class="kt">uint256</span> <span class="n">usdcBalance</span> <span class="o">=</span> <span class="mi">5042</span> <span class="kc">ether</span><span class="p">;</span>
<span class="kt">int24</span> <span class="n">currentTick</span> <span class="o">=</span> <span class="mi">85176</span><span class="p">;</span>
<span class="kt">uint160</span> <span class="n">currentSqrtP</span> <span class="o">=</span> <span class="mi">5602277097478614198912276234240</span><span class="p">;</span>
</code></pre></div></div>
<p>These are the same values we used before. Notice that we’re about to mint 5042 USDC–that’s 5000 USDC we’ll provide as
liquidity into the pool and 42 USDC we’ll sell in a swap.</p>

<p>Next, we define the set of steps that will be executed as the deployment transaction (well, each of the steps will be
a separate transaction). For this, we’re using <code class="language-plaintext highlighter-rouge">startBroadcast/endBroadcast</code> cheat codes:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vm</span><span class="p">.</span><span class="n">startBroadcast</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">vm</span><span class="p">.</span><span class="n">stopBroadcast</span><span class="p">();</span>
</code></pre></div></div>

<blockquote>
  <p>Everything that goes after <code class="language-plaintext highlighter-rouge">broadcast()</code> cheat code or between <code class="language-plaintext highlighter-rouge">startBroadcast/stopBroadcast</code> is converted to
transactions and these transactions are sent to the node that executes the script.</p>
</blockquote>

<p>Between the broadcast cheat codes, we’ll put the actual deployment steps. First, we need to deploy the tokens:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ERC20Mintable</span> <span class="n">token0</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ERC20Mintable</span><span class="p">(</span><span class="s">"Wrapped Ether"</span><span class="p">,</span> <span class="s">"WETH"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
<span class="n">ERC20Mintable</span> <span class="n">token1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ERC20Mintable</span><span class="p">(</span><span class="s">"USD Coin"</span><span class="p">,</span> <span class="s">"USDC"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
</code></pre></div></div>
<p>We cannot deploy the pool without having tokens, so we need to deploy them first.</p>

<blockquote>
  <p>Since we’re deploying to a local development network, we need to deploy the tokens ourselves. In the mainnet and public
test networks (Ropsten, Goerli, Sepolia), the tokens are already created. Thus, to deploy to those networks, we’ll need
to write network-specific deployment scripts.</p>
</blockquote>

<p>The next step is to deploy the pool contract:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UniswapV3Pool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UniswapV3Pool</span><span class="p">(</span>
    <span class="kt">address</span><span class="p">(</span><span class="n">token0</span><span class="p">),</span>
    <span class="kt">address</span><span class="p">(</span><span class="n">token1</span><span class="p">),</span>
    <span class="n">currentSqrtP</span><span class="p">,</span>
    <span class="n">currentTick</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Next, manager contract deployment:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UniswapV3Manager</span> <span class="n">manager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UniswapV3Manager</span><span class="p">();</span>
</code></pre></div></div>

<p>And finally, we can mint some amount of ETH and USDC to our address:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">token0</span><span class="p">.</span><span class="n">mint</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">wethBalance</span><span class="p">);</span>
<span class="n">token1</span><span class="p">.</span><span class="n">mint</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">usdcBalance</span><span class="p">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">msg.sender</code> in Foundy scripts is the address sending transactions, i.e. this is the address that will pay for the
transaction.</p>

<p>Finally, at the end of the script, add some <code class="language-plaintext highlighter-rouge">console.log</code> calls to print the addresses of deployed contracts:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">"WETH address"</span><span class="p">,</span> <span class="kt">address</span><span class="p">(</span><span class="n">token0</span><span class="p">));</span>
<span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">"USDC address"</span><span class="p">,</span> <span class="kt">address</span><span class="p">(</span><span class="n">token1</span><span class="p">));</span>
<span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">"Pool address"</span><span class="p">,</span> <span class="kt">address</span><span class="p">(</span><span class="n">pool</span><span class="p">));</span>
<span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="s">"Manager address"</span><span class="p">,</span> <span class="kt">address</span><span class="p">(</span><span class="n">manager</span><span class="p">));</span>
</code></pre></div></div>

<p>Alright, let’s run the script (ensure Anvil is running in another terminal window):</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>forge script scripts/DeployDevelopment.s.sol <span class="nt">--broadcast</span> <span class="nt">--fork-url</span> localhost:8545 <span class="nt">--private-key</span> <span class="nv">$PRIVATE_KEY</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">--broadcast</code> enables broadcasting of transactions. It’s not enabled by default because not every script sends
transactions. <code class="language-plaintext highlighter-rouge">--fork-url</code> sets the address of the node to send transactions to. <code class="language-plaintext highlighter-rouge">--private-key</code> sets the sender account:
a private key is needed to sign transactions. You can pick any of the private keys printed by Anvil when it’s starting.
I picked the first one:</p>
<blockquote>
  <p>0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80</p>
</blockquote>

<p>Deployment takes several seconds. In the end, you’ll see a list of transactions it sent. It’ll also save transactions
receipts to <code class="language-plaintext highlighter-rouge">broadcast</code> folder. In Anvil, you’ll also see many lines with <code class="language-plaintext highlighter-rouge">eth_sendRawTransaction</code>, <code class="language-plaintext highlighter-rouge">eth_getTransactionByHash</code>,
and <code class="language-plaintext highlighter-rouge">eth_getTransactionReceipt</code>–after sending transactions to Anvil, Forge uses the JSON-RPC API to check their status
and get transaction execution results (receipts).</p>

<p>Congratulations! You’ve just deployed a smart contract!</p>

<h2 id="interacting-with-contracts-abi">Interacting With Contracts, ABI</h2>

<p>Now, let’s see how we can interact with the deployed contracts.</p>

<p>Every contract exposes a set of public functions. In the case of the pool contract, these are <code class="language-plaintext highlighter-rouge">mint</code> and <code class="language-plaintext highlighter-rouge">swap</code>.
Additionally, Solidity creates getters for public variables, so we can also call <code class="language-plaintext highlighter-rouge">token0</code>, <code class="language-plaintext highlighter-rouge">token1</code>, <code class="language-plaintext highlighter-rouge">positions</code>, etc.
However, since contracts are compiled bytecodes, <strong>function names are lost during compilation and not stored on
blockchain</strong>. Instead, every function is identified by a selector, which is the first 4 bytes of the hash of the
signature of the function. In pseudocode:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keccak256("transfer(address,address,uint256)")[0:4]
</code></pre></div></div>

<p>Knowing this, let’s make two calls to the deployed contracts: one will be a low-level call via <code class="language-plaintext highlighter-rouge">curl</code>, and one will be
done via <code class="language-plaintext highlighter-rouge">cast</code>.</p>

<blockquote>
  <p>We’ll soon learn how to make contract calls from a front-end application using a JS library.</p>
</blockquote>

<h3 id="token-balance">Token Balance</h3>
<p>Let’s check the WETH balance of the deployer address. The signature of the function is <code class="language-plaintext highlighter-rouge">balanceOf(address)</code>. To find the
id of this function (its selector), we’ll hash it and take the first four bytes:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cast keccak <span class="s2">"balanceOf(address)"</span>| <span class="nb">cut</span> <span class="nt">-b</span> 1-10
0x70a08231
</code></pre></div></div>

<p>To pass the address, we simply append it to the function selector (and add left padding up to 32 digits since addresses
take 32 bytes in calldata):</p>
<blockquote>
  <p>0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266</code> is the address we’re going to check balance of. This is our address, the first
account in Anvil.</p>

<p>Next, we execute <code class="language-plaintext highlighter-rouge">eth_call</code> JSON-RPC method to make the call. Notice that this doesn’t require sending a transaction–this
endpoint is used to read data from contracts.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ params</span><span class="o">=</span><span class="s1">'{"from":"0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266","to":"0xe7f1725e7734ce288f8367e1bb143e90bb3f0512","data":"0x70a08231000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266"}'</span>
<span class="nv">$ </span>curl <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{"id":1,"jsonrpc":"2.0","method":"eth_call","params":['</span><span class="s2">"</span><span class="nv">$params</span><span class="s2">"</span><span class="s1">',"latest"]}'</span> <span class="se">\</span>
  http://127.0.0.1:8545
<span class="o">{</span><span class="s2">"jsonrpc"</span>:<span class="s2">"2.0"</span>,<span class="s2">"id"</span>:1,<span class="s2">"result"</span>:<span class="s2">"0x00000000000000000000000000000000000000000000011153ce5e56cf880000"</span><span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>The “to” address is the USDC token. It’s printed by the deployment script and it can be different in your case.</p>
</blockquote>

<p>The node responses are in the hexadecimal system. To parse the result, we need to know its type. In the case of <code class="language-plaintext highlighter-rouge">balanceOf</code>
function, the type of returned value is <code class="language-plaintext highlighter-rouge">uint256</code>. Using <code class="language-plaintext highlighter-rouge">cast</code>, we can convert it to a decimal number and then convert
it to ethers:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cast <span class="nt">--to-dec</span> 0x00000000000000000000000000000000000000000000011153ce5e56cf880000| cast <span class="nt">--from-wei</span>
5042.000000000000000000
</code></pre></div></div>

<p>The balance is correct! We minted to ourselves 42 USDC.</p>

<h3 id="current-tick-and-price">Current Tick and Price</h3>

<p>The above example is a demonstration of low-level contract calls. Usually, you never do calls via <code class="language-plaintext highlighter-rouge">curl</code> and use a tool
or library instead. And Cast can help us here again!</p>

<p>Let’s get current pool liquidity using <code class="language-plaintext highlighter-rouge">cast</code>:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>cast call POOL_ADDRESS <span class="s2">"slot0()"</span>| xargs cast <span class="nt">--abi-decode</span> <span class="s2">"a()(uint160,int24)"</span>
5602277097478614198912276234240
85176
</code></pre></div></div>

<p>Nice! The first value is the current $\sqrt{P}$ and the second value is the current tick.</p>

<blockquote>
  <p>Since <code class="language-plaintext highlighter-rouge">--abi-decode</code> requires full function signature we have to specify “a()” even though we only want to decode
function output.</p>
</blockquote>

<h3 id="abi">ABI</h3>

<p>To simplify interaction with contracts, Solidity compiler can output ABI, Application Binary Interface.</p>

<p>ABI is a JSON file that contains the description of all public methods and events of a contract. The goal of this file
is to make it easier to encode function parameters and decode return values. To get ABI with Forge, use this command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>forge inspect UniswapV3Pool abi
</code></pre></div></div>

<p>Feel free skimming through the file better understand its content.</p>
