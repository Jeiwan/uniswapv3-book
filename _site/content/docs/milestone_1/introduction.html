
<blockquote>
  <p>You&#8217;ll find the complete code of this chapter in <a href="https://github.com/Jeiwan/uniswapv3-code/tree/milestone_1">this Github branch</a>.</p>
</blockquote>

<h1 id="first-swap">First Swap</h1>

<p>In this milestone, we&#8217;ll build a pool contract that can receive liquidity from users and make swaps within a price range.
To keep it as simple as possible, we&#8217;ll provide liquidity only in one price range and we&#8217;ll make a swap only in one
direction. Also, we&#8217;ll calculate all the required math manually to get better intuition before starting using mathematical libs.</p>

<p>Let&#8217;s model the situation we&#8217;ll build:</p>
<ol>
  <li>There will be an ETH-USDC pool contract. ETH will be the $x$ reserve; USDC will be the $y$ reserve.</li>
  <li>We&#8217;ll set the current price to 5000 USDC per 1 ETH.</li>
  <li>The range we&#8217;ll provide liquidity is 4545-5500 USDC per 1 ETH.</li>
  <li>We&#8217;ll buy some ETH from the pool. At this point, since we have only one price range, we want the price of the trade
to stay within the price range.</li>
</ol>

<p>Visually, this model looks like this:</p>

<p>[TODO: graph the model]</p>

<p>Before getting to code, let&#8217;s figure out the math and calculate all the parameters of the model. To keep things simple,
I&#8217;ll do all math calculations in Python. This will allow us to focus on the calculations without diving into the nuances
of mathematical operations in Solidity. This also means that, in smart contracts, we&#8217;ll hardcode all the amounts and
values. This might look like a fake, but we want to start with simple contracts that work.</p>

<p>For your convenience, I put all the Python calculations in <a href="https://github.com/Jeiwan/uniswapv3-code/blob/main/unimath.py">unimath.py</a>.</p>
