
<h1 id="first-swap">First Swap</h1>

<p>Now that we have liquidity, we can make our first swap!</p>

<h2 id="calculating-swap-amounts">Calculating Swap Amounts</h2>

<p>First step, of course, is to figure out how to calculate swap amounts. And, again, let’s pick and hardcode some amount
of USDC we’re going to trade in for ETH. Let it be 42! We’re going to buy ETH for 42 USDC.</p>

<p>After deciding how many tokens we want to sell, we need to calculate how many tokens we’ll get in exchange. There are
multiple ways of doing this. In Uniswap V2, we would’ve used current pool reserves, but in Uniswap V3 we have $L$ and
$\sqrt{P}$ and we know the fact that, when swapping within a price range, only $\sqrt{P}$ changes and $L$ remains
unchanged. We also know that:
\(L = \frac{\Delta y}{\Delta \sqrt{P}}\)</p>

<p>And… we know $\Delta y$! This is the 42 USDC we’re going to trade in! Thus, we can find how selling 42 USDC will affect
the current $\sqrt{P}$ given the $L$:</p>

\[\Delta \sqrt{P} = \frac{\Delta y}{L}\]

<p>In Uniswap V3, we choose <strong>the price we want our trade to lead to</strong> (recall that swapping changes the current price, i.e.
it moves the current price along the curve). Knowing the target price, the contract will calculate the amount of input
token it needs to take from us and the respective amount of output token it’ll give us.</p>

<p>Let’s plug in our numbers into the above formula:</p>

\[\Delta \sqrt{P} = \frac{42 \enspace USDC}{1517882343751509868544} = 2192253463713690532467206957\]

<p>After adding this to the current $\sqrt{P}$, we’ll get the target price:</p>

\[\sqrt{P_{target}} = \sqrt{P_{current}} + \Delta \sqrt{P}\]

\[\sqrt{P_{target}} = 5604469350942327889444743441197\]

<blockquote>
  <p>To calculate the target price in Python:</p>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">amount_in</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">*</span> <span class="n">eth</span>
<span class="n">price_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">amount_in</span> <span class="o">*</span> <span class="n">q96</span><span class="p">)</span> <span class="o">//</span> <span class="n">liq</span>
<span class="n">price_next</span> <span class="o">=</span> <span class="n">sqrtp_cur</span> <span class="o">+</span> <span class="n">price_diff</span>
<span class="k">print</span><span class="p">(</span><span class="s">"New price:"</span><span class="p">,</span> <span class="p">(</span><span class="n">price_next</span> <span class="o">/</span> <span class="n">q96</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"New sqrtP:"</span><span class="p">,</span> <span class="n">price_next</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"New tick:"</span><span class="p">,</span> <span class="n">price_to_tick</span><span class="p">((</span><span class="n">price_next</span> <span class="o">/</span> <span class="n">q96</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1"># New price: 5003.913912782393
# New sqrtP: 5604469350942327889444743441197
# New tick: 85184
</span></code></pre></div>  </div>
</blockquote>

<p>After finding the target price, we can calculate token amounts using the amounts calculation functions from a previous
chapter:</p>

<p>\(x = \frac{L(\sqrt{p_b}-\sqrt{p_a})}{\sqrt{p_b}\sqrt{p_a}}\)
\(y = L(\sqrt{p_b}-\sqrt{p_a})\)</p>

<blockquote>
  <p>In Python:</p>
  <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">amount_in</span> <span class="o">=</span> <span class="n">calc_amount1</span><span class="p">(</span><span class="n">liq</span><span class="p">,</span> <span class="n">price_next</span><span class="p">,</span> <span class="n">sqrtp_cur</span><span class="p">)</span>
<span class="n">amount_out</span> <span class="o">=</span> <span class="n">calc_amount0</span><span class="p">(</span><span class="n">liq</span><span class="p">,</span> <span class="n">price_next</span><span class="p">,</span> <span class="n">sqrtp_cur</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"USDC in:"</span><span class="p">,</span> <span class="n">amount_in</span> <span class="o">/</span> <span class="n">eth</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"ETH out:"</span><span class="p">,</span> <span class="n">amount_out</span> <span class="o">/</span> <span class="n">eth</span><span class="p">)</span>
<span class="c1"># USDC in: 42.0
# ETH out: 0.008396714242162444
</span></code></pre></div>  </div>
</blockquote>

<p>To verify the amounts, let’s recall another formula:</p>

\[\Delta x = \Delta \frac{1}{\sqrt{P}} L\]

<p>Using this formula, we can find the amount of ETH we’re buying, $\Delta x$, knowing the price change,
$\Delta\frac{1}{\sqrt{P}}$, and liquidity $L$. Be careful though: $\Delta \frac{1}{\sqrt{P}}$ is not
$\frac{1}{\Delta \sqrt{P}}$! The former is the change of the price of ETH, and it can be found using this expression:</p>

\[\Delta \frac{1}{\sqrt{P}} = \frac{1}{\sqrt{P_{target}}} - \frac{1}{\sqrt{P_{current}}}\]

<p>Luckily, we already know all the values, so we can plug them in right away (this might not fit on your screen!):</p>

\[\Delta \frac{1}{\sqrt{P}} = \frac{1}{5604469350942327889444743441197} - \frac{1}{5602277097478614198912276234240}\]

\[\Delta \frac{1}{\sqrt{P}} = -0.00000553186106731426\]

<p>Now, let’s find $\Delta x$:</p>

\[\Delta x = -0.00000553186106731426 * 1517882343751509868544 = -8396714242162698\]

<p>Which is 0.008396714242162698 ETH, and it’s very close to the amount we found above! Notice that this amount is negative
since we’re removing it from the pool.</p>

<h2 id="implementing-a-swap">Implementing a Swap</h2>

<p>Swapping is implemented in <code class="language-plaintext highlighter-rouge">swap</code> function:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">swap</span><span class="p">(</span><span class="kt">address</span> <span class="n">recipient</span><span class="p">)</span>
    <span class="k">public</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">int256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">amount1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
</code></pre></div></div>
<p>At this moment, it only takes a recipient, who is a receiver of tokens.</p>

<p>First, we need to find the target price and tick, as well as calculate the token amounts. Again, we’ll simply hardcode
the values we calculated earlier to keep things as simple as possible:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="kt">int24</span> <span class="n">nextTick</span> <span class="o">=</span> <span class="mi">85184</span><span class="p">;</span>
<span class="kt">uint160</span> <span class="n">nextPrice</span> <span class="o">=</span> <span class="mi">5604469350942327889444743441197</span><span class="p">;</span>

<span class="n">amount0</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.008396714242162444</span> <span class="kc">ether</span><span class="p">;</span>
<span class="n">amount1</span> <span class="o">=</span> <span class="mi">42</span> <span class="kc">ether</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Next, we need to update the current tick and <code class="language-plaintext highlighter-rouge">sqrtP</code> since trading affects the current price:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="p">(</span><span class="n">slot0</span><span class="p">.</span><span class="n">tick</span><span class="p">,</span> <span class="n">slot0</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextTick</span><span class="p">,</span> <span class="n">nextPrice</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Next, the contract sends tokens to the recipient and lets the caller transfer the input amount into the contract:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="n">IERC20</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="nb">transfer</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">(</span><span class="o">-</span><span class="n">amount0</span><span class="p">));</span>

<span class="kt">uint256</span> <span class="n">balance1Before</span> <span class="o">=</span> <span class="n">balance1</span><span class="p">();</span>
<span class="n">IUniswapV3SwapCallback</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">).</span><span class="n">uniswapV3SwapCallback</span><span class="p">(</span>
    <span class="n">amount0</span><span class="p">,</span>
    <span class="n">amount1</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">balance1Before</span> <span class="o">+</span> <span class="kt">uint256</span><span class="p">(</span><span class="n">amount1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">balance1</span><span class="p">())</span>
    <span class="nb">revert</span> <span class="n">InsufficientInputAmount</span><span class="p">();</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Again, we’re using a callback to pass the control to the caller and let it transfer the tokens. After that, we’re checking
that pool’s balance is correct and includes the input amount.</p>

<p>Finally, the contract emits a <code class="language-plaintext highlighter-rouge">Swap</code> event to make the swap discoverable. The event includes all the information about
the swap:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="k">emit</span> <span class="n">Swap</span><span class="p">(</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span>
    <span class="n">recipient</span><span class="p">,</span>
    <span class="n">amount0</span><span class="p">,</span>
    <span class="n">amount1</span><span class="p">,</span>
    <span class="n">slot0</span><span class="p">.</span><span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="n">liquidity</span><span class="p">,</span>
    <span class="n">slot0</span><span class="p">.</span><span class="n">tick</span>
<span class="p">);</span>
</code></pre></div></div>

<p>And that’s it! The function simply sends some amount of tokens to the specified recipient address and expects a certain
number of the other token in exchange. Throughout this book, the function will get much more complicated.</p>

<h2 id="testing-swapping">Testing Swapping</h2>

<p>Now, we can test the swap function. In the same test file, create <code class="language-plaintext highlighter-rouge">testSwapBuyEth</code> function and set up the test case. This
test case uses the same parameters as <code class="language-plaintext highlighter-rouge">testMintSuccess</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">testSwapBuyEth</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
    <span class="n">TestCaseParams</span> <span class="k">memory</span> <span class="n">params</span> <span class="o">=</span> <span class="n">TestCaseParams</span><span class="p">({</span>
        <span class="n">wethBalance</span><span class="o">:</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span>
        <span class="n">usdcBalance</span><span class="o">:</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span>
        <span class="n">currentTick</span><span class="o">:</span> <span class="mi">85176</span><span class="p">,</span>
        <span class="n">lowerTick</span><span class="o">:</span> <span class="mi">84222</span><span class="p">,</span>
        <span class="n">upperTick</span><span class="o">:</span> <span class="mi">86129</span><span class="p">,</span>
        <span class="n">liquidity</span><span class="o">:</span> <span class="mi">1517882343751509868544</span><span class="p">,</span>
        <span class="n">currentSqrtP</span><span class="o">:</span> <span class="mi">5602277097478614198912276234240</span><span class="p">,</span>
        <span class="n">shouldTransferInCallback</span><span class="o">:</span> <span class="nb">true</span><span class="p">,</span>
        <span class="n">mintLiqudity</span><span class="o">:</span> <span class="nb">true</span>
    <span class="p">});</span>
    <span class="p">(</span><span class="kt">uint256</span> <span class="n">poolBalance0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">poolBalance1</span><span class="p">)</span> <span class="o">=</span> <span class="n">setupTestCase</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>

    <span class="p">...</span>
</code></pre></div></div>

<p>Next steps will be different, however.</p>

<blockquote>
  <p>We’re not going to test that liquidity has been correctly added to the pool since we tested this functionality in the
other test cases.</p>
</blockquote>

<p>To make the test swap, we need 42 USDC:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">token1</span><span class="p">.</span><span class="n">mint</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="mi">42</span> <span class="kc">ether</span><span class="p">);</span>
</code></pre></div></div>

<p>Before making the swap, we need to ensure we can transfer tokens to the pool contract when it requests them:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">uniswapV3SwapCallback</span><span class="p">(</span><span class="kt">int256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">amount1</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">token0</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">(</span><span class="n">amount0</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">token1</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="kt">uint256</span><span class="p">(</span><span class="n">amount1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Since amounts during a swap can be positive (the amount that’s sent to the pool) and negative (the amount that’s taken
from the pool), in the callback, we only want to send the positive amount, i.e. the amount we’re trading in.</p>

<p>Now, we can call <code class="language-plaintext highlighter-rouge">swap</code>:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">int256</span> <span class="n">amount0Delta</span><span class="p">,</span> <span class="kt">int256</span> <span class="n">amount1Delta</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">));</span>
</code></pre></div></div>

<p>The function returns token amounts used in the swap, and we can check them right away:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEq</span><span class="p">(</span><span class="n">amount0Delta</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.008396714242162444</span> <span class="kc">ether</span><span class="p">,</span> <span class="s">"invalid ETH out"</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">amount1Delta</span><span class="p">,</span> <span class="mi">42</span> <span class="kc">ether</span><span class="p">,</span> <span class="s">"invalid USDC in"</span><span class="p">);</span>
</code></pre></div></div>

<p>Then, we need to ensure that tokens were actually transferred from the caller:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEq</span><span class="p">(</span>
    <span class="n">token0</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">)),</span>
    <span class="kt">uint256</span><span class="p">(</span><span class="n">userBalance0Before</span> <span class="o">-</span> <span class="n">amount0Delta</span><span class="p">),</span>
    <span class="s">"invalid user ETH balance"</span>
<span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">token1</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">)),</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="s">"invalid user USDC balance"</span>
<span class="p">);</span>
</code></pre></div></div>

<p>And sent to the pool contract:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEq</span><span class="p">(</span>
    <span class="n">token0</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">pool</span><span class="p">)),</span>
    <span class="kt">uint256</span><span class="p">(</span><span class="kt">int256</span><span class="p">(</span><span class="n">poolBalance0</span><span class="p">)</span> <span class="o">+</span> <span class="n">amount0Delta</span><span class="p">),</span>
    <span class="s">"invalid pool ETH balance"</span>
<span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">token1</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">pool</span><span class="p">)),</span>
    <span class="kt">uint256</span><span class="p">(</span><span class="kt">int256</span><span class="p">(</span><span class="n">poolBalance1</span><span class="p">)</span> <span class="o">+</span> <span class="n">amount1Delta</span><span class="p">),</span>
    <span class="s">"invalid pool USDC balance"</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Finally, we’re checking that the pool state was updated correctly:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="kt">int24</span> <span class="n">tick</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">slot0</span><span class="p">();</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="mi">5604469350942327889444743441197</span><span class="p">,</span>
    <span class="s">"invalid current sqrtP"</span>
<span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">tick</span><span class="p">,</span> <span class="mi">85184</span><span class="p">,</span> <span class="s">"invalid current tick"</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">liquidity</span><span class="p">(),</span>
    <span class="mi">1517882343751509868544</span><span class="p">,</span>
    <span class="s">"invalid current liquidity"</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Notice that swapping doesn’t change the current liquidity–in a later chapter, we’ll see when it does change it.</p>

<h2 id="homework">Homework</h2>

<p>Write a test that fails with <code class="language-plaintext highlighter-rouge">InsufficientInputAmount</code> error. Keep in mind that there’s a hidden bug 🙂</p>
