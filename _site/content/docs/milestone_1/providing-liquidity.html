
<h1 id="providing-liquidity">Providing Liquidity</h1>

<p>Enough of theory, let’s start coding!</p>

<p>Create a new folder (mine is called <code class="language-plaintext highlighter-rouge">uniswapv3-code</code>), and run <code class="language-plaintext highlighter-rouge">forge init --vscode</code> in it–this will initialize a Forge
project. The <code class="language-plaintext highlighter-rouge">--vscode</code> flag tells Forge to configure the Solidity extension for Forge projects.</p>

<p>Next, remove the default contract and its test:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">script/Contract.s.sol</code></li>
  <li><code class="language-plaintext highlighter-rouge">src/Contract.sol</code></li>
  <li><code class="language-plaintext highlighter-rouge">test/Contract.t.sol</code></li>
</ul>

<p>And that’s it! Let’s create our first contract!</p>

<h2 id="pool-contract">Pool Contract</h2>

<p>As you’ve learned from the introduction, Uniswap deploys multiple Pool contracts, each of which is an exchange market of
a pair of tokens. Uniswap groups all its contract into two categories:</p>

<ul>
  <li>core contracts, and</li>
  <li>periphery contracts.</li>
</ul>

<p>Core contracts are, as the name implies, the contracts that implement core logic. These are minimal, user-<em>un</em>friendly,
low-level contracts. Their purpose is to do one thing. In Uniswap V3, there are 2 such contracts:</p>
<ol>
  <li>Pool contract, which implements the core logic of a decentralized exchange.</li>
  <li>Factory contract, which serves as a registry of Pool contracts and a contract that makes deployment of pools easier.</li>
</ol>

<p>We’ll begin with the pool contract. Create <code class="language-plaintext highlighter-rouge">src/UniswapV3Pool.sol</code>:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: UNLICENSED
</span><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">14</span><span class="p">;</span>

<span class="k">contract</span> <span class="n">UniswapV3Pool</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Let’s think about what data the contract will store:</p>
<ol>
  <li>Since every pool contract is an exchange market of two tokens, we need to track the two token addresses. And these
addresses will be static, set once and forever during contract initialization.</li>
  <li>Each pool contract is a set of liquidity positions, a data structure to manage positions identified by: liquidity
provider’s address, and upper and lower bounds of the position.</li>
  <li>Each pool contract will also need to maintain a ticks registry and information about each tick–the amount of liquidity
provided by each tick.</li>
  <li>Since the tick range is limited, we need to store the limits in the contract, as constants.</li>
  <li>And as we discussed in the introduction, pool contracts store the amount of liquidity, $L$, and $\sqrt{P}$ instead of
token reserves. So we’ll need to store them in the contract as well.</li>
</ol>

<p>Here’s what our pool contract with all the state variables:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">contract</span> <span class="n">UniswapV3Pool</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">Tick</span> <span class="k">for</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">);</span>
    <span class="k">using</span> <span class="n">Position</span> <span class="k">for</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="n">Position</span><span class="p">.</span><span class="n">Info</span><span class="p">);</span>
    <span class="k">using</span> <span class="n">Position</span> <span class="k">for</span> <span class="n">Position</span><span class="p">.</span><span class="n">Info</span><span class="p">;</span>

    <span class="kt">int24</span> <span class="k">internal</span> <span class="k">constant</span> <span class="n">MIN_TICK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">887272</span><span class="p">;</span>
    <span class="kt">int24</span> <span class="k">internal</span> <span class="k">constant</span> <span class="n">MAX_TICK</span> <span class="o">=</span> <span class="o">-</span><span class="n">MIN_TICK</span><span class="p">;</span>

    <span class="c1">// Pool tokens, immutable
</span>    <span class="kt">address</span> <span class="k">public</span> <span class="kr">immutable</span> <span class="n">token0</span><span class="p">;</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="kr">immutable</span> <span class="n">token1</span><span class="p">;</span>

    <span class="c1">// First slot will contain essential data
</span>    <span class="k">struct</span> <span class="n">Slot0</span> <span class="p">{</span>
        <span class="c1">// Current sqrt(P)
</span>        <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">;</span>
        <span class="c1">// Current tick
</span>        <span class="kt">int24</span> <span class="n">tick</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Slot0</span> <span class="k">public</span> <span class="n">slot0</span><span class="p">;</span>

    <span class="c1">// Amount of liquidity, L.
</span>    <span class="kt">uint128</span> <span class="k">public</span> <span class="n">liquidity</span><span class="p">;</span>

    <span class="c1">// Ticks info
</span>    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">public</span> <span class="n">ticks</span><span class="p">;</span>
    <span class="c1">// Positions info
</span>    <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="n">Position</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">public</span> <span class="n">positions</span><span class="p">;</span>

    <span class="p">...</span>
</code></pre></div></div>

<p>Uniswap V3 uses many helper contracts and <code class="language-plaintext highlighter-rouge">Tick</code> and <code class="language-plaintext highlighter-rouge">Position</code> are two of them. <code class="language-plaintext highlighter-rouge">using A for B</code> is a feature of Solidity
that lets you extend type <code class="language-plaintext highlighter-rouge">B</code> with functions from library contract <code class="language-plaintext highlighter-rouge">A</code>. This simplifies managing complex data structures.</p>

<blockquote>
  <p>For brevity, I’ll omit detailed explanation of Solidity syntax and features. Solidity has <a href="https://docs.soliditylang.org/en/latest/">great documentation</a>,
don’t hesitate referring to it if something is not clear!</p>
</blockquote>

<p>We’ll then initialize them in the constructor:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">constructor</span><span class="p">(</span>
        <span class="kt">address</span> <span class="n">token0_</span><span class="p">,</span>
        <span class="kt">address</span> <span class="n">token1_</span><span class="p">,</span>
        <span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span>
        <span class="kt">int24</span> <span class="n">tick</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="n">token0</span> <span class="o">=</span> <span class="n">token0_</span><span class="p">;</span>
        <span class="n">token1</span> <span class="o">=</span> <span class="n">token1_</span><span class="p">;</span>

        <span class="n">slot0</span> <span class="o">=</span> <span class="n">Slot0</span><span class="p">({</span><span class="n">sqrtPriceX96</span><span class="o">:</span> <span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="n">tick</span><span class="o">:</span> <span class="n">tick</span><span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that we’re passing $\sqrt{P}$ and the current tick index without providing liquidity–this sets the current price.</p>

<blockquote>
  <p>We’re setting both $\sqrt{P}$ and tick index in the constructor for simplicity. Later on, we’ll implement the conversion
between $\sqrt{P}$ and tick indexes.</p>
</blockquote>

<p>This is our starting point, and our goal in this chapter is to make our first swap.</p>

<h2 id="minting">Minting</h2>

<p>The process of providing liquidity in Uniswap V2 is called <em>minting</em>. The reason is that the V2 pool contract mints
tokens (LP-tokens) in exchange for liquidity. V3 doesn’t do that, but it still uses the same name for the function. Let’s
use it as well:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">mint</span><span class="p">(</span>
    <span class="kt">address</span> <span class="n">owner</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">lowerTick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">upperTick</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">amount</span>
<span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount1</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">mint</code> function will take:</p>
<ol>
  <li>Owner’s address, to track the owner of the liquidity.</li>
  <li>Upper and lower ticks, to set the bounds of a price range.</li>
  <li>The amount of liquidity we have provided.</li>
</ol>

<p>When adding initial liquidity to a pool, this function adds a new tick and a position.</p>

<p>We begin with checking the ticks:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span>
    <span class="n">lowerTick</span> <span class="o">&gt;=</span> <span class="n">upperTick</span> <span class="o">||</span>
    <span class="n">lowerTick</span> <span class="o">&lt;</span> <span class="n">MIN_TICK</span> <span class="o">||</span>
    <span class="n">upperTick</span> <span class="o">&gt;</span> <span class="n">MAX_TICK</span>
<span class="p">)</span> <span class="nb">revert</span> <span class="n">InvalidTickRange</span><span class="p">();</span>
</code></pre></div></div>

<p>And ensuring that some amount of liquidity is provided:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="nb">revert</span> <span class="n">ZeroLiquidity</span><span class="p">();</span>
</code></pre></div></div>

<p>Then, add a tick and a position:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ticks</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">lowerTick</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
<span class="n">ticks</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">upperTick</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>

<span class="n">Position</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">position</span> <span class="o">=</span> <span class="n">positions</span><span class="p">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">owner</span><span class="p">,</span>
    <span class="n">lowerTick</span><span class="p">,</span>
    <span class="n">upperTick</span>
<span class="p">);</span>
<span class="n">position</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">amount</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ticks.update</code> function is:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/libs/Tick.sol
</span><span class="p">...</span>
<span class="k">function</span> <span class="n">update</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">int24</span> <span class="o">=&gt;</span> <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">tick</span><span class="p">,</span>
    <span class="kt">uint128</span> <span class="n">liquidityDelta</span>
<span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
    <span class="n">Tick</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">tickInfo</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span><span class="n">tick</span><span class="p">];</span>
    <span class="kt">uint128</span> <span class="n">liquidityBefore</span> <span class="o">=</span> <span class="n">tickInfo</span><span class="p">.</span><span class="n">liquidity</span><span class="p">;</span>
    <span class="kt">uint128</span> <span class="n">liquidityAfter</span> <span class="o">=</span> <span class="n">liquidityBefore</span> <span class="o">+</span> <span class="n">liquidityDelta</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">liquidityBefore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tickInfo</span><span class="p">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tickInfo</span><span class="p">.</span><span class="n">liquidity</span> <span class="o">=</span> <span class="n">liquidityAfter</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>
<p>It initialized a tick if it has 0 liquidity before and adds new liquidity to it. As you can see, we’re calling this
function on both lower and upper ticks, thus liquidity is added to both of them–we’ll see why later on.</p>

<p>The <code class="language-plaintext highlighter-rouge">position.update</code> function is:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/libs/Position.sol
</span><span class="k">function</span> <span class="n">update</span><span class="p">(</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span> <span class="kt">uint128</span> <span class="n">liquidityDelta</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
    <span class="kt">uint128</span> <span class="n">liquidityBefore</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">liquidity</span><span class="p">;</span>
    <span class="kt">uint128</span> <span class="n">liquidityAfter</span> <span class="o">=</span> <span class="n">liquidityBefore</span> <span class="o">+</span> <span class="n">liquidityDelta</span><span class="p">;</span>

    <span class="n">self</span><span class="p">.</span><span class="n">liquidity</span> <span class="o">=</span> <span class="n">liquidityAfter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Similar to the tick update function, it adds liquidity to a specific position. And to get a position we call:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// src/libs/Position.sol
</span><span class="p">...</span>
<span class="k">function</span> <span class="n">get</span><span class="p">(</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="n">Info</span><span class="p">)</span> <span class="k">storage</span> <span class="n">self</span><span class="p">,</span>
    <span class="kt">address</span> <span class="n">owner</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">lowerTick</span><span class="p">,</span>
    <span class="kt">int24</span> <span class="n">upperTick</span>
<span class="p">)</span> <span class="k">internal</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Position</span><span class="p">.</span><span class="n">Info</span> <span class="k">storage</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">self</span><span class="p">[</span>
        <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">lowerTick</span><span class="p">,</span> <span class="n">upperTick</span><span class="p">))</span>
    <span class="p">];</span>
<span class="p">}</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Each position is uniquely identified by three keys: owner address, lower tick index, and upper tick index. We’re storing
positions in a <code class="language-plaintext highlighter-rouge">bytes32 =&gt; Info</code> map and are using hashes of concatenated owner address, lower tick, and upper tick as
keys. This is cheaper than storing three nested maps.</p>

<p>We’re not done yet! Next, we need to calculate the amounts that the user must deposit. Luckily, we have already figured
out the formulas and calculated the exact amounts in the previous part. So, we’re going to hardcode the amounts:</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">amount0</span> <span class="o">=</span> <span class="mf">0.998976618347425280</span> <span class="kc">ether</span><span class="p">;</span>
<span class="n">amount1</span> <span class="o">=</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>We’ll replace these with actual calculations in a later chapter.</p>
</blockquote>

<p>Now, we’re ready to take tokens from the user. This is done via a callback:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint256</span> <span class="n">balance0Before</span><span class="p">;</span>
<span class="kt">uint256</span> <span class="n">balance1Before</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">balance0Before</span> <span class="o">=</span> <span class="n">balance0</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">balance1Before</span> <span class="o">=</span> <span class="n">balance1</span><span class="p">();</span>
<span class="n">IUniswapV3MintCallback</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">).</span><span class="n">uniswapV3MintCallback</span><span class="p">(</span>
    <span class="n">amount0</span><span class="p">,</span>
    <span class="n">amount1</span>
<span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">amount0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">balance0Before</span> <span class="o">+</span> <span class="n">amount0</span> <span class="o">&gt;</span> <span class="n">balance0</span><span class="p">())</span>
    <span class="nb">revert</span> <span class="n">InsufficientInputAmount</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">amount1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">balance1Before</span> <span class="o">+</span> <span class="n">amount1</span> <span class="o">&gt;</span> <span class="n">balance1</span><span class="p">())</span>
    <span class="nb">revert</span> <span class="n">InsufficientInputAmount</span><span class="p">();</span>
</code></pre></div></div>

<p>First, we record current token balances (if either of them is deposited). Then we call <code class="language-plaintext highlighter-rouge">uniswapV3MintCallback</code> method
on the caller–this is the callback. It’s expected that the caller (whoever executes <code class="language-plaintext highlighter-rouge">mint</code>) is a contract because
non-contract addresses cannot implement functions in Ethereum. There are two reason doing this like that:</p>

<ol>
  <li>Pool contract is a core contract, and core contracts are user-unfriendly. It’s expected that core contracts are only
user by other contracts which make interaction with a pool easier.</li>
  <li>We don’t want to calculate the square root of reserves in the contract because it’s an expensive operation. But we still
need to be sure that the liquidity deposited by user is correct. To achieve this, we calculate $\Delta x$ and $\Delta y$,
which doesn’t require calculating square roots. But this approach forces us to use a callback to let the caller know the
actual amounts they need to deposit.</li>
</ol>

<p>In production, Pool contracts are called from the Router contract, which handles all the nuances. We’ll implement it in
a later chapter.</p>

<p>Finally, we’re firing a <code class="language-plaintext highlighter-rouge">Mint</code> event:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">emit</span> <span class="n">Mint</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">lowerTick</span><span class="p">,</span> <span class="n">upperTick</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">amount0</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>
</code></pre></div></div>

<p>Events is how contract data is indexed in Ethereum for later search. It’s a good practice to fire an event whenever
contract’s state is changed to let blockchain explorer know when this happened. Events also carry useful information.
In our case it’s: caller’s address, liquidity position owner’s address, upper and lower ticks, new liquidity, and token
amounts. This information will be stored as a log, and anyone else will be able to collect all contract events and
reproduce activity of the contract without traversing and analyzing all blocks and transactions.</p>

<p>And we’re done! Phew! Now, let’s test minting.</p>

<h2 id="testing">Testing</h2>

<p>At this point we don’t know if everything works correctly. Before deploying our contract anywhere we’re going to write
a bunch of tests to ensure the contract works correctly. Luckily to us, Forge is a great testing framework and it’ll
make testing a breeze.</p>

<p>Create a new test file:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//test/UniswapV3Pool.t.sol
// SPDX-License-Identifier: UNLICENSED
</span><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">14</span><span class="p">;</span>

<span class="k">import</span> <span class="s">"forge-std/Test.sol"</span><span class="p">;</span>

<span class="k">contract</span> <span class="n">UniswapV3PoolTest</span> <span class="k">is</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="k">function</span> <span class="n">setUp</span><span class="p">()</span> <span class="k">public</span> <span class="p">{}</span>

    <span class="k">function</span> <span class="n">testExample</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="n">assertTrue</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s run it:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>forge <span class="nb">test
</span>Running 1 <span class="nb">test </span><span class="k">for </span><span class="nb">test</span>/UniswapV3Pool.t.sol:UniswapV3PoolTest
<span class="o">[</span>PASS] testExample<span class="o">()</span> <span class="o">(</span>gas: 279<span class="o">)</span>
Test result: ok. 1 passed<span class="p">;</span> 0 failed<span class="p">;</span> finished <span class="k">in </span>5.07ms
</code></pre></div></div>

<p>It passes! Of course it is! So far, our test only checks that <code class="language-plaintext highlighter-rouge">true</code> is <code class="language-plaintext highlighter-rouge">true</code>!</p>

<p>Test contract are just contract that inherit from <code class="language-plaintext highlighter-rouge">forge-std/Test.sol</code>. This contract is a set of testing utilities, we’ll
get acquainted with them step by step. If you don’t want wait, open <code class="language-plaintext highlighter-rouge">lib/forge-std/src/Test.sol</code> and skim through it!</p>

<p>Test contracts follow a specific convention:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">setUp</code> function is used to set up test cases. In each test cases, we want to have configured environment, like
deployed contracts, minted tokens, initialized pools–we’ll do all this in <code class="language-plaintext highlighter-rouge">setUp</code>.</li>
  <li>Every test case starts with <code class="language-plaintext highlighter-rouge">test</code> prefix, e.g. <code class="language-plaintext highlighter-rouge">testMint()</code>. This will let Forge distinguish test cases from helper
functions (we can add any function we want).</li>
</ol>

<p>Let’s test minting!</p>

<h3 id="test-tokens">Test Tokens</h3>

<p>To test minting we need tokens. This is not a problem because we can deploy any contract in tests! Moreover, Forge can
install open-source contracts as dependencies. Specifically, we need an ERC20 contract with minting functionality. We’ll
use the ERC20 contract from <a href="https://github.com/Rari-Capital/solmate">solmate</a>, a collection of gas-optimized contracts
(however, we don’t care about gas optimization at this moment) and we’ll extend it in a contract that allows public
minting.</p>

<p>Let’s install <code class="language-plaintext highlighter-rouge">solmate</code>:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>forge <span class="nb">install </span>rari-capital/solmate
</code></pre></div></div>

<p>Then, let’s create <code class="language-plaintext highlighter-rouge">ERC20Mintable.sol</code> contract in <code class="language-plaintext highlighter-rouge">test</code> folder (we’ll use the contract only in tests):</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SPDX-License-Identifier: UNLICENSED
</span><span class="k">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.8</span><span class="p">.</span><span class="mi">14</span><span class="p">;</span>

<span class="k">import</span> <span class="s">"solmate/tokens/ERC20.sol"</span><span class="p">;</span>

<span class="k">contract</span> <span class="n">ERC20Mintable</span> <span class="k">is</span> <span class="n">ERC20</span> <span class="p">{</span>
    <span class="k">constructor</span><span class="p">(</span>
        <span class="kt">string</span> <span class="k">memory</span> <span class="n">_name</span><span class="p">,</span>
        <span class="kt">string</span> <span class="k">memory</span> <span class="n">_symbol</span><span class="p">,</span>
        <span class="kt">uint8</span> <span class="n">_decimals</span>
    <span class="p">)</span> <span class="n">ERC20</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_symbol</span><span class="p">,</span> <span class="n">_decimals</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">function</span> <span class="n">mint</span><span class="p">(</span><span class="kt">address</span> <span class="n">to</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="n">_mint</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">ERC20Mintable</code> inherits all functionality from <code class="language-plaintext highlighter-rouge">solmate/tokens/ERC20.sol</code> and we additionally implement public <code class="language-plaintext highlighter-rouge">mint</code>
method which will allow us to mint any number of tokens.</p>

<h3 id="minting-1">Minting</h3>

<p>Now, we’re ready to test minting.</p>

<p>First, let’s deploy all the required contracts:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// test/UniswapV3Pool.t.sol
</span><span class="p">...</span>
<span class="k">import</span> <span class="s">"./ERC20Mintable.sol"</span><span class="p">;</span>
<span class="k">import</span> <span class="s">"../src/UniswapV3Pool.sol"</span><span class="p">;</span>

<span class="k">contract</span> <span class="n">UniswapV3PoolTest</span> <span class="k">is</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="n">ERC20Mintable</span> <span class="n">token0</span><span class="p">;</span>
    <span class="n">ERC20Mintable</span> <span class="n">token1</span><span class="p">;</span>
    <span class="n">UniswapV3Pool</span> <span class="n">pool</span><span class="p">;</span>

    <span class="k">function</span> <span class="n">setUp</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="n">token0</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ERC20Mintable</span><span class="p">(</span><span class="s">"Ether"</span><span class="p">,</span> <span class="s">"ETH"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
        <span class="n">token1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ERC20Mintable</span><span class="p">(</span><span class="s">"USDC"</span><span class="p">,</span> <span class="s">"USDC"</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">...</span>
</code></pre></div></div>
<p>In the <code class="language-plaintext highlighter-rouge">setUp</code> function, we do things that are required for all our test cases–tokens deployment. We’ll need the two
tokens in every future test case (and we’ll add more tokens later on). However, we’re not going to deploy the pool here
because each test case will need a pool with different parameters.</p>

<p>To make pool setting up cleaner and simpler, we’ll do this in a separate function, <code class="language-plaintext highlighter-rouge">setupTestCase</code>, that takes a set of
test case parameters. In our first test case, we’ll test successful liquidity minting. This is what the test case
parameters look like:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">testMintSuccess</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
    <span class="n">TestCaseParams</span> <span class="k">memory</span> <span class="n">params</span> <span class="o">=</span> <span class="n">TestCaseParams</span><span class="p">({</span>
        <span class="n">wethBalance</span><span class="o">:</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span>
        <span class="n">usdcBalance</span><span class="o">:</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">,</span>
        <span class="n">currentTick</span><span class="o">:</span> <span class="mi">85176</span><span class="p">,</span>
        <span class="n">lowerTick</span><span class="o">:</span> <span class="mi">84222</span><span class="p">,</span>
        <span class="n">upperTick</span><span class="o">:</span> <span class="mi">86129</span><span class="p">,</span>
        <span class="n">liquidity</span><span class="o">:</span> <span class="mi">1517882343751509868544</span><span class="p">,</span>
        <span class="n">currentSqrtP</span><span class="o">:</span> <span class="mi">5602277097478614198912276234240</span><span class="p">,</span>
        <span class="n">shouldTransferInCallback</span><span class="o">:</span> <span class="nb">true</span><span class="p">,</span>
        <span class="n">mintLiqudity</span><span class="o">:</span> <span class="nb">true</span>
    <span class="p">});</span>
    <span class="p">(</span><span class="kt">uint256</span> <span class="n">poolBalance0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">poolBalance1</span><span class="p">)</span> <span class="o">=</span> <span class="n">setupTestCase</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
</code></pre></div></div>
<ol>
  <li>We’re planning to deposit 1 ETH and 5000 USDC into the pool.</li>
  <li>We want the current tick to be 85176, and lower and upper ticks being 84222 and 86129 respectively.</li>
  <li>We’re specifying the precalculated liquidity and current $\sqrt{P}$.</li>
  <li>We also want to deposit liquidity (<code class="language-plaintext highlighter-rouge">mintLiquidity</code> parameter) and transfer tokens when requested by the pool contract
(<code class="language-plaintext highlighter-rouge">shouldTransferInCallback</code>). We don’t want to do this in each test case, so we want this to be optional.</li>
</ol>

<p>Next, we’re calling <code class="language-plaintext highlighter-rouge">setupTestCase</code> with the above parameters:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">setupTestCase</span><span class="p">(</span><span class="n">TestCaseParams</span> <span class="k">memory</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="n">poolBalance0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">poolBalance1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">token0</span><span class="p">.</span><span class="n">mint</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">params</span><span class="p">.</span><span class="n">wethBalance</span><span class="p">);</span>
    <span class="n">token1</span><span class="p">.</span><span class="n">mint</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">params</span><span class="p">.</span><span class="n">usdcBalance</span><span class="p">);</span>

    <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UniswapV3Pool</span><span class="p">(</span>
        <span class="kt">address</span><span class="p">(</span><span class="n">token0</span><span class="p">),</span>
        <span class="kt">address</span><span class="p">(</span><span class="n">token1</span><span class="p">),</span>
        <span class="n">params</span><span class="p">.</span><span class="n">currentSqrtP</span><span class="p">,</span>
        <span class="n">params</span><span class="p">.</span><span class="n">currentTick</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">mintLiqudity</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">poolBalance0</span><span class="p">,</span> <span class="n">poolBalance1</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">mint</span><span class="p">(</span>
            <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span>
            <span class="n">params</span><span class="p">.</span><span class="n">lowerTick</span><span class="p">,</span>
            <span class="n">params</span><span class="p">.</span><span class="n">upperTick</span><span class="p">,</span>
            <span class="n">params</span><span class="p">.</span><span class="n">liquidity</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">shouldTransferInCallback</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">shouldTransferInCallback</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In this function, we’re minting tokens and deploying a pool (unconditionally), as well as providing liquidity when
<code class="language-plaintext highlighter-rouge">mintLiquidity</code> is set and setting <code class="language-plaintext highlighter-rouge">shouldTransferInCallback</code> flag. We’ll then check the flag in the mint callback:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">uniswapV3MintCallback</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">amount0</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">amount1</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shouldTransferInCallback</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">token0</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount0</span><span class="p">);</span>
        <span class="n">token1</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">,</span> <span class="n">amount1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Recall that test contracts act as users. Thus, this test contract must implement <code class="language-plaintext highlighter-rouge">uniswapV3MintCallback</code> so it could
call the <code class="language-plaintext highlighter-rouge">mint</code> function.</p>

<p>Setting up test cases like that is not mandatory, you can do it however feels most comfortable to you. Test contracts are
just contracts. You can implement whatever helper functions you want.</p>

<p>In <code class="language-plaintext highlighter-rouge">testMintSuccess</code>, we want to test that the pool contract:</p>
<ol>
  <li>takes the correct amounts of tokens from us;</li>
  <li>creates a position with correct key and liquidity;</li>
  <li>initializes the upper and lower ticks we’ve specified;</li>
  <li>has proper current $\sqrt{P}$ and $L$.</li>
</ol>

<p>Let’s do this.</p>

<p>Minting happens in <code class="language-plaintext highlighter-rouge">setupTestCase</code>, so we don’t need to do this again. The function also returns the amounts we have
provided, so let’s check them:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint256</span> <span class="n">expectedAmount0</span> <span class="o">=</span> <span class="mf">0.998976618347425280</span> <span class="kc">ether</span><span class="p">;</span>
<span class="kt">uint256</span> <span class="n">expectedAmount1</span> <span class="o">=</span> <span class="mi">5000</span> <span class="kc">ether</span><span class="p">;</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">poolBalance0</span><span class="p">,</span>
    <span class="n">expectedAmount0</span><span class="p">,</span>
    <span class="s">"incorrect token0 deposited amount"</span>
<span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">poolBalance1</span><span class="p">,</span>
    <span class="n">expectedAmount1</span><span class="p">,</span>
    <span class="s">"incorrect token1 deposited amount"</span>
<span class="p">);</span>
</code></pre></div></div>
<p>We expect specific pre-calculated amounts. And we can also check that these amounts were actually transferred to the pool:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEq</span><span class="p">(</span><span class="n">token0</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">pool</span><span class="p">)),</span> <span class="n">expectedAmount0</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">token1</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">pool</span><span class="p">)),</span> <span class="n">expectedAmount1</span><span class="p">);</span>
</code></pre></div></div>

<p>Next, we need to check the position the pool created for us. Remember that the key in <code class="language-plaintext highlighter-rouge">positions</code> mapping is a hash? We
need to calculate it manually and then get our position from the contract:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bytes32</span> <span class="n">positionKey</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span>
    <span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="n">params</span><span class="p">.</span><span class="n">lowerTick</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">upperTick</span><span class="p">)</span>
<span class="p">);</span>
<span class="kt">uint128</span> <span class="n">posLiquidity</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">positions</span><span class="p">(</span><span class="n">positionKey</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">posLiquidity</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">liquidity</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>Since <code class="language-plaintext highlighter-rouge">Position.Info</code> is a <a href="https://docs.soliditylang.org/en/latest/types.html#structs">struct</a>, it gets destructured
when fetched: each field gets fetched separately.</p>
</blockquote>

<p>[TODO: double-check]</p>

<p>Next come the ticks. Again, it’s straightforward:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">bool</span> <span class="n">tickInitialized</span><span class="p">,</span> <span class="kt">uint128</span> <span class="n">tickLiquidity</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">ticks</span><span class="p">(</span>
    <span class="n">params</span><span class="p">.</span><span class="n">lowerTick</span>
<span class="p">);</span>
<span class="n">assertTrue</span><span class="p">(</span><span class="n">tickInitialized</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">tickLiquidity</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">liquidity</span><span class="p">);</span>

<span class="p">(</span><span class="n">tickInitialized</span><span class="p">,</span> <span class="n">tickLiquidity</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">ticks</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">upperTick</span><span class="p">);</span>
<span class="n">assertTrue</span><span class="p">(</span><span class="n">tickInitialized</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">tickLiquidity</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">liquidity</span><span class="p">);</span>
</code></pre></div></div>

<p>And finally $\sqrt{P}$ and $L$:</p>
<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">uint160</span> <span class="n">sqrtPriceX96</span><span class="p">,</span> <span class="kt">int24</span> <span class="n">tick</span><span class="p">)</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">slot0</span><span class="p">();</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">sqrtPriceX96</span><span class="p">,</span>
    <span class="mi">5602277097478614198912276234240</span><span class="p">,</span>
    <span class="s">"invalid current sqrtP"</span>
<span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span><span class="n">tick</span><span class="p">,</span> <span class="mi">85176</span><span class="p">,</span> <span class="s">"invalid current tick"</span><span class="p">);</span>
<span class="n">assertEq</span><span class="p">(</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">liquidity</span><span class="p">(),</span>
    <span class="mi">1517882343751509868544</span><span class="p">,</span>
    <span class="s">"invalid current liquidity"</span>
<span class="p">);</span>
</code></pre></div></div>

<p>As you can see, writing tests in Solidity is not hard!</p>

<h3 id="failures">Failures</h3>

<p>Of course, testing only successful scenarios is not enough. We also need to test failing cases. What can go wrong when
providing liquidity? Here are a couple of hints:</p>
<ol>
  <li>Upper and lower ticks are too big or too low.</li>
  <li>Zero liquidity is provided.</li>
  <li>Liquidity provider doesn’t have enough of tokens.</li>
</ol>

<p>I’ll leave it for you to implement these scenarios! Feel free peeking at <a href="https://github.com/Jeiwan/uniswapv3-code/blob/milestone_1/test/UniswapV3Pool.t.sol">the code in the repo</a>.</p>
